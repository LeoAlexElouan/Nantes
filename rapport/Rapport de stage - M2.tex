\documentclass[11pt]{article}
\usepackage{graphicx} % Required for inserting images
\usepackage[a4paper, lmargin = 1cm, rmargin =1cm, tmargin = 1cm, bmargin = 2cm]{geometry}


\usepackage{tikz}
\usetikzlibrary{cd}
\usepackage{quiver}

\usepackage[sorting=none]{biblatex}
\addbibresource{reference.bib}


\usepackage{mathrsfs}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{stmaryrd }
\usepackage[T1]{fontenc}
\usepackage{euscript}



\usepackage{adjustbox}

\usepackage{color}


\usepackage{semantic}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{ndefinition}[theorem]{Not-a-Definition}

\DeclareMathOperator{\colim}{colim}
\DeclareMathOperator{\Prop}{\mathsf{Prop}}
\DeclareMathOperator{\SProp}{\mathsf{SProp}}
\DeclareMathOperator{\Type}{\mathsf{Type}}
\DeclareMathOperator{\ask}{\mathsf{ask}}
\DeclareMathOperator{\bind}{\mathsf{bind}}
\DeclareMathOperator{\Inductive}{\mathsf{Inductive}}
\DeclareMathOperator{\ret}{\mathsf{ret}}
\DeclareMathOperator{\rec}{rec}
\DeclareMathOperator{\ctx}{\mathsf{ctx}}
\DeclareMathOperator{\Typ}{\mathsf{Typ}}
\DeclareMathOperator{\trm}{\mathsf{Trm}}
\DeclareMathOperator{\true}{\mathsf{tt}}
\DeclareMathOperator{\false}{\mathsf{ff}}


\newcommand{\ovarr}{\overrightarrow}
\newcommand{\ovl}{\overline}
\newcommand{\omlim}{A_0+\sum\limits_{i\geq 1}\ovl A_i}

\newcommand{\0}{\mathbf{0}}
\newcommand{\1}{\mathbf{1}}
\newcommand{\nat}{\mathbf{N}}
\newcommand{\bool}{\mathbf{B}}
\newcommand{\C}{\mathcal{C}}
\newcommand{\D}{\mathcal{D}}
\newcommand{\SBS}{\mathbf{SBS}}

\newcommand{\Gram}{\mathsf{G}}
\newcommand{\mono}{\rightarrowtail}
\newcommand{\omop}{\omega^{op}}
\newcommand{\omopch}{\Theta}
\newcommand{\omch}{\Omega}
\newcommand{\Dist}{\mathsf{Dist}}
\newcommand{\gd}{\dot {\mathbf{Fun}}}
\newcommand{\colomf}[1]{\varinjlim\circ\omch_{#1}^{(-)}}
\newcommand{\colom}[2]{\varinjlim(\omch_{#1}^{#2})}
\newcommand{\lcontext}{\Gamma}
\newcommand{\rcontext}{\Delta}
\newcommand{\lvar}{\gamma}
\newcommand{\rvar}{\delta}

\newcommand{\tctx}{\Gamma}
\newcommand{\tvar}{\gamma}
\newcommand{\diag}{\Delta}
\newcommand{\DThunk}{\mathsf{Dist}}

\newcommand{\Unit}{\mathsf{Unit}}
\newcommand{\Bool}{\mathsf{Bool}}
\newcommand{\Real}{\mathsf{Real}}
\newcommand{\Nat}{\mathsf{Nat}}
\newcommand{\List}{\textsf{List}}
\newcommand{\Stream}{\textsf{Stream}}

\newcommand{\Wf}{\textsf{well-formed}}
\newcommand{\slvl}{\mathbf{s}}
\newcommand{\llvl}{\mathbf{l}}
\newcommand{\fctx}{\mathcal{L}}


\mathlig{<-}{\leftarrow}
\mathlig{->}{\to}
\mathlig{|->}{\mapsto}
\mathlig{=>}{\Rightarrow}
\mathlig{|-}{\vdash}
\mathlig{[|}{\llbracket}
\mathlig{|]}{\rrbracket}

\mathlig{==}{\equiv}

\reservestyle{\command}{\mathsf}
\command{inl,inr,wrap,roll,rec,corec,as,match,return,let,in,sample,on,do}


% Distributions in programming language
\newcommand{\Uniform}{\mathsf{uniform}}


\title{Internship report M2\\  Non-singleton Elimination\\}
\author{\textbf{Soudant L\'eo}, supervised by \textbf{Pierre-Marie P\'edrot}, Galinette team}
\date{2025}


\begin{document}


\begin{titlepage}
    
\maketitle

\end{titlepage}


\subsection*{General context}
We attempt to create type theories corresponding with the properties of the internal languages of sheaf topo誰. Martin Baillon succeeded for some instance of the problem.
\subsection*{Research problem}
An element of a topological sheaf may be defined over an open whenever it is defined on a cover of that open, so long as they are compatible over the intersections. We hope to be able to do something similar in a type theory, where open set correspond to proof irrelevant propositions. This requires special attention to the compatibility condition : when a disjunction covers a proposition, it should be possible to eliminate from this disjunction to create a term in any type whenever compatible marginal terms are found.
\subsection*{Your contribution}
I have proved using \textsc{Rocq} that a system T with a part of the wanted features normalises. I also have a model in \textsc{Rocq} where types are interpreted as sheaves, even though some other variant probably exists.
\subsection*{Arguments supporting its validity}
The type theory devellopped by Martin Baillon, which I aim to generalise, proved continuity of all functional $(\nat -> \bool) -> \bool$. I hope to find similar results at term.
\subsection*{Summary and future works}
I will refine the type theory further as well as study other instances like the one Martin Baillon studied. I should also make a fork of the logrel \textsc{Rocq} project, and adapt it to my theory.
\newpage
\tableofcontents
\newpage


\section{Introduction}




\subsection{The outline}

\section{Sheaves}

\subsection{Sheaves on topological spaces}

We fix a topological space $X$, in this case presheves on that space are presheaves on the category underlying its poset of open subsets. More precisely :

\begin{definition}[Presheaf on a topology]
    A \emph{presheaf} $P$ is given by
    \begin{itemize}
        \item For every open $U \in \mathcal{O}(X)$, a set $P(U)$ of \emph{sections}
        \item For every open $U$, section $s\in P(U)$, and open subset $V\subseteq U$, a \emph{restriction} $s|_V\in P(V)$
        \item If $s\in P(U)$, $s|_U = s$
        \item If $s\in P(U)$, $W\subseteq V \subseteq U$, $(s|_V)|_W = s|_W$
    \end{itemize}
\end{definition}
The $\lambda (s\in P(U)), s|_V : P(U) -> P(V)$ function gives the $P(f)$ necessary to construct the functor $P : \mathcal{O}(X)^{op} -> \mathbf{Set}$ justifying the use of the same term presheaf here and in the categorical context.

While in general presheaves are unrelated to sheaves, we can introduce what sheaves look like in the topos (see definition \ref{topos}) of presheaves.

\begin{definition}[Sheaf on a topology]
    A \emph{sheaf} $\mathcal{F}$ is a presheaf such that given any open  $U$ and family of open $(U_i)_i$ such that $U = \bigcup_i U_i$, there is a bijection between :
    \begin{itemize}
        \item Sections $s$ of $U$
        \item Families $(s_i\in \mathcal{F}(U_i))_i$ of sections where $s_i|_{U_i\cap U_j} = s_j|_{U_i\cap U_j}$
    \end{itemize}
    where the forward direction is given by $s \mapsto (s|_{U_i})_i$.
\end{definition}

Since the definition only acces the open subsets and not the points of the space, they can be extended to \emph{locales}, that is, posets with finite meets and arbitrary joins satisfying the infinite distributive law. As far as we are concerned, this means $\vee,\wedge$ and $\leq$ will be used instead $\cup,\cap$ and $\subseteq$.

\subsection{Kripke and Beth semantics}

Presheaves give a classical tool to study intuitionistic logic through Kripke models. 

Formula are relativised to an open subset (in general an object in a small category) or \emph{forcing condition} $U$ : $U \models \phi$, and the requirement for the formula to be verified is strengthened by asking for it to be verified on every $V\leq U$. This requirement degenerates back to the usual except in the $=>$ and $\forall$ case : 
\begin{itemize}
    \item $U |= \phi \wedge \psi$ iff for all $V\leq U$, $V |= \phi$ and $V |= \psi$ iff $U |= \phi$ and $U |= \psi$
    \item $U |= \phi => \psi$ iff for all $V \leq U$, if $V |= \phi$ then $V |= \psi $
    \item $U |= \forall x : P, \phi$ iff for all $V \leq U$ and $s\in P(V)$, $V |= \phi(s/x) $
\end{itemize}

Since the key example of forcing condition is the context, it is perhaps unsurprising that the only connectors affected by are the one affecting the context (including the free variables in the context).

Where presheaves and their Kripke semantics strengthened the requirements (not unlike intuitionistic logic has less tools), sheaves and their Beth semantics lower them again.

Again, this weakened requirements degenerates in most cases.

\begin{itemize}
    \item $U |= \phi \wedge \psi$ iff there exists $(U_i)_i$ with $U = \bigwedge_i U_i$, such that for all $i$, $U_i |= \phi$ and $U_i |= \psi $ iff $U |= \phi$ and $U |= \psi$.
    \item $U |= \phi \vee \psi $ iff there exists $(U_i)_i$ with $U = \bigwedge_i U_i$, such that for all $i$, $U_i |= \phi$ or $U_i |= \psi $.
    \item $U |= \exists x : \mathcal{F}, \phi $ iff there exists $(U_i)_i$ with $U = \bigwedge_i U_i$, such that for all $i$, there exists $s_i\in \mathcal{F}(U_i)$, $U_i |= \phi(s_i/x)$.
\end{itemize}

We note that $U |= \phi$ iff for all $V\leq U$, $V |= \phi$ in the case of kripke semantics and iff there exists $(U_i)_i$ with $U = \bigwedge_i U_i$, such that for all $i$, $U_i |= \phi$ in the case of Beth semantics, as can be shown by induction on $\phi$ in both cases.

The goal of this stage may be formulated as bringing this weakening of condition into type theory.

\subsection{Topo誰 and sheaves in topo誰}


Proofs, results and details for this section can often be found in \emph{Sheaves in geometry and logic: A first introduction to topos theory} by Saunders Maclane and Ieke Moerdijk \cite{maclane2012sheaves}.

\begin{definition}[Subobject]
    In a category, a \emph{subobject} of $X$ is an equivalence class of monomorphism $m : A \mono X$, where the equivalence comes from the preorder where $ m : A \mono X $ is smaller than $ m' : A' \mono X$ when there is a map $f : A -> A'$ with $ m' \circ f = m$.
\end{definition}

We deduce a presheaf $\mathbf{Sub}$ where $\mathbf{Sub}(X)$ is the the set of subobjects of $X$, and $\mathbf{Sub}(f) : \mathbf{Sub}(Y) -> \mathbf{Sub}(X)$ sends $m : A -> Y$ to its pullback by $f : X -> Y $. 

\begin{definition}[Topos]\label{topos}
    A \emph{topos} is a cartesian closed category with all finite limits and a suboject \emph{classifier} $\Omega$ and an isomorphism $\mathbf{Sub}(X)\cong \mathbf{Hom}(X, \Omega)$ natural in $X$.
\end{definition}

We note that topo誰 also have finite colimits.

A topos serves to give models of intuitionistic logic in classical mathematical language. It has an internal logic which is higher order.

For example, $\mathbf{Set}$ is a topos, and given a topos $\mathcal E$, $\mathcal{E}/X$, the category of maps with codomain $X$ and commuting triangles, as well as $\mathcal{E}^{\mathbf{C}^{op}}$, the category of contravariant functors from a small category $\mathbf{C}$ and natural transformation, are all topo誰. In particular categories of presheaves are topo誰, and correspond to Kripke models. 

The subobject classifier $\Omega$ is equipped with an internal meet-semilattice structure inherited from the meet-semilattice structure on each $\mathbf{Sub}(X)$, which is natural in $X$.

\begin{definition}[Lawvere-Tierney topology]
    A \emph{Lawvere-Tierney topology} is a left exact idempotent monad $j$ on the internal meet-semilattice on $\Omega$.
\begin{itemize}
    \item $ id_\Omega \leq j $,
    \item $ j\circ j \leq  j$
    \item $ j \circ \wedge = \wedge \circ j\times j$
\end{itemize}
\end{definition}

From a topology $j$ we extract a closure operator $J_X$ of $\mathbf{Sub}(X)$ for any $X$.
\begin{definition}[Dense subobject]
    A suboject $U$ of $X$ is dense if $J_XU  = X$
\end{definition}

A topology can be lifted to a left exact idempotent monad on the entirety of the topos, the sheafification monad.

\begin{definition}[$j$-Sheaf in topos]
    An object $F$ is a $j$-\emph{sheaf} in a topos if for any dense subobject $U$ of any object $X$, the morphism $\mathbf{Hom}(X, F) -> \mathbf{Hom}(U, F)$ obtained by precomposition is an isomorphism.
\end{definition}

A $j$-Sheaf is up to isomorphism the result of sheafifying an object.

$j$-Sheaves form a topos. The sheaves on a presheaf topos correspond to Beth semantics.

\subsection{Geometric formulas}
In the litterature around sheaves and forcing, we find the following definitions.
\begin{ndefinition}
A \emph{geometric formula} is a formula built from $\exists, \wedge,\bigvee$, and atomic formulas.
\end{ndefinition}
\begin{ndefinition}
A \emph{geometric implication} is a formula of shape $\forall \overrightarrow{x}, \phi(\overrightarrow{x}) -> \psi(\overrightarrow{x})$, where $\phi$ and $\psi$ are geometric.
\end{ndefinition}
\begin{ndefinition}
    A \emph{geometric theory} is a set geometric implication.
\end{ndefinition}
We rather use the following definition

\begin{definition}
    A \emph{geometric formula} is a formula of the form $$\bigwedge_{i\in I}\left(\forall \overrightarrow{x}, \bigwedge_{j \in J_i} O_{i,j}(\overrightarrow{x}) -> \bigvee_{k\in K_i}\exists \overrightarrow{y},\bigwedge_{l\in L_{i,k}} Q_{i,k,l}(\overrightarrow{x},\overrightarrow{y})\right)$$
    Where $O_{i,j}$ and $Q_{i,k,l}$ are atomic formulas, and both every $J_i$ and every $L_{i,k}$ are finite.
\end{definition}

Every \guillemetleft geometric theory \guillemetright can be written as a single geometric formula.

We'd like to note that they define covers and be read as saying that some intersection of atoms can be covered by a family of intersection of atoms, and that they may be integrated in a deduction system as : 
$$
    \inference[\textsc{Geo}-$i$]{Q_{i,1,1}(\overrightarrow{x},\overrightarrow{t_1})\dots Q_{i,1,m_{i,1}}(\overrightarrow{x},\overrightarrow{t_1})|-\mathcal{J}\ \cdots\ Q_{i,p_i,1}(\overrightarrow{x},\overrightarrow{t_{p_i}})\dots Q_{i,p_i,m_{i,p_i}}(\overrightarrow{x},\overrightarrow{t_{p_i}})|-\mathcal{J}}{O_{i,1}(\overrightarrow{x}),\dots O_{i,n_i}(\overrightarrow{x})|-\mathcal{J}}
$$


\subsection{Sheaves in type theory}

Consider a type theory with a notion of proof irrelevant propositions $\Prop$, \emph{e.g.} book-HoTT with mere propositions, or \textsc{Rocq} with $\SProp$.

In this case, a Lawvere-Tierney topology may be similarily defined, as a monad:
\begin{itemize}
    \item $\mathsf{J} : \Prop -> \Prop$
    \item $\eta : \Pi (P:\Prop).P -> \mathsf{J}\ P$
    \item $\bind : \forall (P Q: \Prop). \mathsf{J}\ P -> (P -> \mathsf{J}\ Q) -> \mathsf{J}\ Q$
\end{itemize}

Then a sheaf is just a type $T$ with 
\begin{itemize}
    \item A map $\ask_T : \Pi (P:\Prop).\ \mathsf{J}\ P -> (P -> T) -> T$
    \item A coherence $\varepsilon_T : \Pi (P:\Prop)\ (j : \mathsf{J}\ P)\ (x:T).\ \ask_T\ P\ j\ (\lambda p:P.x) = x$
\end{itemize}

Now, the sheafified of a type doesn't exists in general, if the theory admits quotient inductive types, it can then be defined as follow :

$$
\begin{array}{l}
    \Inductive\ \mathcal{S}_{\mathsf{J}}\ T : \Type := \\
    | \ret : T -> \mathcal{S}_{\mathsf{J}}\ T\\
    | \ask : \Pi (P:\Prop), \mathsf{J}\ P -> (P -> \mathcal{S}_{\mathsf{J}}\ T) -> \mathcal{S}_{\mathsf{J}}\ T\\
    |\ \varepsilon : \Pi (P:\Prop)\ (j : \mathsf J\ P)\ (x : \mathcal{S}_{\mathsf{J}}\ T). \ask\ P\ j\ (\lambda p:P. x) = x
\end{array}
$$

We note that by taking $I := \Sigma (P:\Prop). \mathsf{J}\ P$ and $O\ (P,j) : P$, a sheaf is then defined as
\begin{definition}\label{IOshf}
    A \emph{sheaf} or \emph{$(I,O)$-sheaf}, is given by
\begin{itemize}
    \item A type $T$
    \item A map $\ask_T : \Pi (i:I), (O\ i -> T) -> T$
    \item A coherence map $\varepsilon_T : \Pi(i:I)\ (x:T), \ask_T\ i\ (\lambda o:O\  i.x) = x$
\end{itemize}

\end{definition}

$(I,O)$-Sheafification can be defined similarily. This definition is marginally simpler, and make sheaves appear as quotient dialogue trees, hence why we will henceforth consider \emph{$(I,O)$-sheaves} instead of \emph{$\mathsf{J}$-sheaves}.

It is also possible to see geometric formulas as being of the form $\Pi i : I, O i$, and as such be used as the basis for sheaves.

\section{Models}

A significant part of my internship was dedicated to contructing models of type theory in \textsc{Rocq}.

\begin{enumerate}
    \item A model of a variant of Baclofen TT using dialogue trees. Predicates must be linearized before eliminating an inductive into them.
    \item An exceptional model, with a type of exceptions $E$. A special type of dialogue trees where $I = E$ and $O i = \mathbf{0}$, the resulting theory is inconsistent (when $E$ is inhabited), as always when $O i -> \mathbf{0}$ for some $i$.
    \item A model using $(I,O)$-sheaves, which requires univalence, and quotient inductive types to model positive types.
    \item A incomplete model using presheaves.
\end{enumerate}

The most important one is of course the model using sheaves.

The model requires univalence and used rewrite rules to simulate HIT, which are absent in \textsc{Rocq} 9.0.0. \textsc{Rocq} served as both the meta-theory and the target, as with all the other models.

Types were interpreted as sheaves as described in definition \ref{IOshf}. Product types are relatively easy as an aribtray product of sheaves is still a sheaf. Positives types, in my case boolean, where contructed as the QIT with the same constructor as the original (true and false), together with $\ask$ and $\varepsilon$. The resulting type is equivalent to the sheafification of booleans but does not compute exactly the same.

One of the interest of type theory is that it yield meaningful computations from proof, so we were careful about that.


\section{System T and MLTT}
\subsection{MLTT}
We sought to extend the following variant of MLTT.

We consider a type of levels containing two elements $\slvl$ and $\llvl$ for small and large, with generic $\ell$

With terms :

$$ M,N ::= x | \lambda x. M | MN | 0 | S | \nat_{\rec} | \bot_{\rec} | \nat | \bot | \Pi x :A.B | \square_\slvl | \square_\llvl$$


Contexts :
$$ \tctx ::= \tctx, x : A | \cdot $$

And conversion rules :

$$
    \inference[\textsc{Wf-Empty}]{}{\cdot |- \Wf} \qquad
    \inference[\textsc{Wf-Ext}]{\tctx |- A == A & \tctx |- \Wf}{ \tctx, x : A |- \Wf}
$$
$$
    \inference[\textsc{Int-Typ}]{\tctx |- \Wf}{\tctx |- \nat == \nat : \square_\ell} \qquad
    \inference[\textsc{Emp-Typ}]{\tctx |- \Wf}{\tctx |- \bot == \bot : \square_\ell}
$$
$$
    \inference[\textsc{Fun-Typ}]{\tctx |- A == A' : \square_\ell & \tctx, x : A |- B == B' : \square_\ell}{\tctx |- \Pi x  : A, B == \Pi x: A', B' : \square_\ell} \qquad
    \inference[\textsc{Typ-Typ}]{\tctx |- \Wf}{\tctx |- \square_\slvl : \square_\llvl}
$$


$$
    \inference[\textsc{Fun-Intro}]{\tctx, x : A |- M == M' : B &\tctx |- A == A : \square_\ell}{\tctx |- \lambda x. M == \lambda x. M' : \Pi x : A, B} \quad
    \inference[\textsc{Fun-Elim}]{\tctx |- M == M' : \Pi x:A, B& \tctx |- N == N' : A}{\tctx |- MN == M'N' : B(N/x)}
$$

$$
    \inference[\textsc{Axiom}]{\tctx |- \Wf & x : A \in \tctx }{\tctx |- x == x : A} \qquad
    \inference[\textsc{Beta}]{\tctx, x : A |- M == M' : B & \tctx |- N == N' : A}{\tctx |- (\lambda x. M)N == M'(N'/x) : B(N/x)}
$$

$$
    \inference[\textsc{Int-Zero}]{\tctx |- \Wf}{\tctx |- 0 == 0 : \nat} \qquad
    \inference[\textsc{Int-Succ}]{\tctx |- \Wf}{\tctx |- S == S : \nat -> \nat}
$$

$$
    \inference[\textsc{Int-Rec}]{\tctx |- \Wf}{\tctx |- \nat_{\rec} == \nat_{\rec} : \Pi A : \nat \to \square_\slvl, A 0 \to \left(\Pi n:\nat, A n \to A (S n)\right) \to \Pi n :\nat, A n}
$$


$$
    \inference[\textsc{Int-Rec-Zero}]{\tctx |- A == A : \nat -> square_\slvl & \tctx |- N_0 == N'_0 == A 0\\ \tctx |- N_S == N_S : \Pi n:\nat, A n -> A(S n)}{\tctx |- \nat_{\rec} A N_0N_S0 == N'_0 : A 0}
$$
$$
    \inference[\textsc{Int-Rec-Succ}]{\tctx |- A == A' : \nat -> square_\slvl & \tctx |- N_0 == N'_0 == A 0\\ \tctx |- N_S == N'_S : \Pi n:\nat, A n -> A(S n) & \tctx |- N == N' :\nat}{\tctx |- \nat_{\rec} A N_0N_S (S N) == N'_S N' (\nat_{\rec}A' N'_0 N'_S N') : A (S N)}
$$


$$
    \inference[\textsc{Emp-Rec}]{\tctx |- \Wf}{\tctx |- \bot_{\rec} == \bot_{\rec} : \Pi A : \bot \to \square_\slvl,\Pi e :\bot, A e}
$$

$$
    \inference[\textsc{Sym}]{\tctx |- M == M' : A}{\tctx |- M' == M : A} \qquad
    \inference[\textsc{Trans}]
    {\tctx |- M == M' :A & \tctx |- M' == M'' : A}{\tctx |- M == M'' : A}
$$

$$
    \inference[\textsc{Conv}]
    {\tctx |- M == M' :A & \tctx |- A == A' : \square_\ell}{\tctx M ==M' : A'}
$$

But it is useful to consider the extension, with new terms :
 $ M,N ::= \dots | \bool|\bool_{\rec}|\ovl\true|\ovl\false$

 And conversion rules

$$
    \inference[\textsc{Bool-True}]{\tctx |- \Wf}{\tctx |- \ovl\true == \ovl\true : \bool} \qquad
    \inference[\textsc{Bool-False}]{\tctx |- \Wf}{\tctx |- \ovl\false == \ovl\false : \bool}
$$

$$
    \inference[\textsc{Bool-Rec}]{\tctx |- \Wf}{\tctx |- \bool_{\rec} == \bool_{\rec} : \Pi A : \bool \to \square_\slvl, A \ovl\true \to A\ovl\false \to \Pi b :\bool, A b}
$$


$$
    \inference[\textsc{Bool-Rec-True}]{\tctx |- A == A : \bool -> \square_\slvl \\ \tctx |- M_{\ovl\true} == M'_{\ovl\true} == A {\ovl\true} & \tctx |- M_{\ovl\false} == M_{\ovl\false} : A \ovl\false}{\tctx |- \bool_{\rec} A M_{\true} M_{\false} \ovl\true == M'_{\ovl\true} : A \ovl\true}
$$
$$
    \inference[\textsc{Bool-Rec-False}]{\tctx |- A == A : \bool -> \square_\slvl \\ \tctx |- M_{\ovl\true} == M_{\ovl\true} == A \ovl\true & \tctx |- M_{\ovl\false} == M'_{\ovl\false} : A \ovl\false}{\tctx |- \bool_{\rec} A M_{\ovl\true} M_{\ovl\false} \ovl\false == M'_{\ovl\false} : A \ovl\false}
$$
\subsection{System T}

To identify and solve problems in a simpler envirronement, we studied a modified System T before, based on the following variant.

With types :

$$ A ::= A -> A | \nat | \bot $$

Terms :

$$ M,N ::= x | \lambda x. M | MN | 0 | S | \nat_{\rec} | \bot_{\rec} $$


Contexts :
$$ \tctx ::= \tctx, x : A | \cdot $$

And conversion rules :


$$
    \inference[\textsc{Fun-Intro}]{\tctx, x : A |- M == M' : B }{\tctx |- \lambda x. M == \lambda x. M' : A -> B} \qquad
    \inference[\textsc{Fun-Elim}]{\tctx |- M == M' : A -> B& \tctx |- N == N' : A}{\tctx |- MN == M'N' : B}
$$

$$
    \inference[\textsc{Axiom}]{x : A \in \tctx }{\tctx |- x == x : A} \qquad
    \inference[\textsc{Beta}]{\tctx, x : A |- M == M' : B & \tctx |- N == N' : A}{\tctx |- (\lambda x. M)N == M' : B}
$$

$$
    \inference[\textsc{Int-Zero}]{\tctx |- \Wf}{\tctx |- 0 == 0 : \nat} \qquad
    \inference[\textsc{Int-Succ}]{\tctx |- \Wf}{\tctx |- S == S : \nat -> \nat}
$$

$$
    \inference[\textsc{Int-Rec}]{\tctx |- \Wf}{\tctx |- \nat_{\rec} == \nat_{\rec} : A \to \left(\nat -> A -> A \right) -> \nat -> A}
$$


$$
    \inference[\textsc{Int-Rec-Zero}]{\tctx |- N_0 == N'_0 == A\\ \tctx |- N_S == N_S : \nat -> A  -> A}{\tctx |- \nat_{\rec} N_0N_S0 == N'_0 : A}
$$
$$
    \inference[\textsc{Int-Rec-Succ}]{\tctx |- N_0 == N'_0 == A\\ \tctx |- N_S == N'_S : \nat -> A  -> A & \tctx |- N == N' :\nat}{\tctx |- \nat_{\rec} N_0N_S (S N) == N'_S N' (\nat_{\rec}N'_0 N'_S N') : A}
$$


$$
    \inference[\textsc{Emp-Rec}]{}{\tctx |- \bot_{\rec} == \bot_{\rec} : \bot -> A}
$$

$$
    \inference[\textsc{Sym}]{\tctx |- M == M' : A}{\tctx |- M' == M : A} \qquad
    \inference[\textsc{Trans}]
    {\tctx |- M == M' :A & \tctx |- M' == M'' : A}{\tctx |- M == M'' : A}
$$

\section{ShTT}
\subsection{Martin Baillon's ShTT}\label{MBshtt}
My work was meant to generalise the work of my supervisor past PhD student, Martin Baillon. He worked on a roughly similar MLTT extended with boolean and a generic function $\alpha$.

$$ M, N ::= \dots |\alpha$$

With \emph{forcing contexts}, with $n$ and $b$ an integer and boolean respectively
$$ \fctx ::= \fctx, n \mapsto b | \cdot$$
We write $n\mapsto_\fctx b$ when $n\mapsto b$ appears in $\fctx$, and $n\not\mapsto_\fctx$ when neither $n\mapsto \true$ nor $n\mapsto \false$ do.

And conversion rules :
$$
    \inference[name]{\fctx,\tctx |- ?_0 & \cdots & \fctx,\tctx |- ?_n}{\fctx,\tctx |- ?}
$$
whenever the following is a rule of MLTT (with booleans)
$$
    \inference[name]{\tctx |- ?_0 & \cdots & \tctx |- ?_n}{\tctx |- ?}
$$

Exception made of \textsc{Wf-Empty}, which becomes
$$
    \inference[\textsc{Wf-Empty}]{}{\cdot,\cdot |- \Wf}
$$

The new conversion rules are :
$$
    \inference[\textsc{Wf-Ext-Forc}]{\fctx,\tctx |- \Wf & n\not\mapsto_\fctx}{\fctx, n\mapsto b, \tctx |- \Wf}
$$
$$
    \inference[\textsc{Gen}]{\fctx,\tctx|- \Wf}{\fctx,\tctx |- \alpha == \alpha : \nat -> \bool}
    \qquad
    \inference[\textsc{Ask}]{\fctx,\tctx|- \Wf &n\mapsto_\fctx b}{\fctx, \tctx |- \alpha \ovl n == \ovl b}
$$
$$
    \inference[\textsc{Split}]{\fctx,n\mapsto \true,\tctx |-M == M' :A & \fctx, n\mapsto\false, \tctx |- M == M' : A & n\not\mapsto_\fctx}{\fctx,\tctx |- M == M' : A}
$$

Amongst other thing, this theory can be used to show that any term $\cdot |- M == M : (\nat -> \bool) -> \nat$ of MLTT has a continuity proof.
\subsection{ShTT}

Being sheaves, the model of every type contained a map $\ask$, we sought to create our type theory of sheaves by adding this map to the syntax under the name $\digamma$

We imagine we have a set $\Omega$ of \emph{atoms}.
We first set a set $I$ with decidable equality, and a (morally finite) set $A i$ for each $i \in I$ standing for arity, and finally a family $((O_{i,\alpha})_{\alpha \in A i})_{i\in I}$ of elements of $\Omega$.

This roughly correspond to the geometric formula : 
$\bigwedge_{i\in I} \top -> \bigvee_{\alpha \in A\ i}O_{i,\alpha}$

The term extend those of MLTT as follows :

$$ M, N ::= \dots | \digamma_i (M_\alpha)_{\alpha\in A i}$$

When instanciating with finite $A i$, it would rather be  $\digamma_i M_1 \cdots M_n$.

The forcing contexts $\fctx$ are now subset of $\Omega$, and never cause ill-formation.

The conversion rules also copy those from MLTT by adding a forcing context as in \ref{MBshtt}, without the \textsc{WF-Empty} exception.

The new conversion rules are as follows :

$$
    \inference[\textsc{Dig}-$i$]{\forall \alpha\alpha'. \fctx,O_{i,\alpha},O_{i,\alpha'},\tctx |- M_\alpha == M'_{\alpha'} : A}{\fctx,\tctx |- \digamma_i (M_\alpha)_\alpha == \digamma_i (M'_\alpha)_\alpha: A}
$$

This rule is both the expected congruence rule for conversion and also a compatibility rule for typing that would be stated separately in a system with a purre typing judgement.

$$
    \inference[\textsc{Ask}-$i$]{\forall \alpha\alpha'. \fctx,O_{i,\alpha},O_{i,\alpha'},\tctx |- M_\alpha == M'_{\alpha'} : A}{\fctx,O_{i,\alpha},\tctx |- \digamma_i (M_{\alpha'})_{\alpha'} == M'_\alpha: A}
$$
$$
    \inference[\textsc{Dig-Ev}]{\fctx,\tctx |- N == N' : A & \forall \alpha \alpha', \fctx, O_{i,\alpha},O_{i,\alpha},\tctx |- M_\alpha == M_{\alpha'} : \Pi x : A, B}{\fctx,\tctx |- (\digamma_i (M_\alpha)_\alpha) N == \digamma (M_\alpha N)_\alpha : B(N/x)}
$$
$$
    \inference[\textsc{Int-Rec-Dig}]{\fctx,\tctx |- A == A : \nat -> \square_\slvl & \fctx,\tctx |- M_0 == M'_0 : \nat & \fctx,\tctx |- M_S == M'_S : \Pi n : \nat, A n -> A (S n)\\ \forall \alpha \alpha', \fctx, O_{i,\alpha},O_{i,\alpha},\tctx |- M_\alpha == M_{\alpha'} : \nat}{\fctx,\tctx |- \nat_{\rec} AM_0M_S(\digamma_i (M_\alpha)_\alpha) == \digamma_i (\nat_{\rec}M_0M_SM_\alpha)_\alpha : A \digamma_i (M_\alpha)_\alpha}
$$
$$
    \inference[\textsc{Emp-Rec-Dig}]{\fctx,\tctx |- A == A : \bot -> \square_\slvl & \forall \alpha \alpha', \fctx, O_{i,\alpha},O_{i,\alpha},\tctx |- M_\alpha == M_{\alpha'} : \bot}{\fctx,\tctx |- \bot_{\rec} A(\digamma_i (M_\alpha)_\alpha) == \digamma_i (\bot_{\rec}M_\alpha)_\alpha : A \digamma_i (M_\alpha)_\alpha}
$$

This theory is still incomplete. For example, to instantiate it with \ref{MBshtt}, even adding the necessary generic function $\alpha$, and setting $I := \nat$, $A i = \bool$ and $O_{n,b} := n\mapsto b$ so that \textsc{Dig}-$i$ may play the role of \textsc{Split}, we  have no way to provide the compatibility proof $n\mapsto \true, n\mapsto \false |- M_{\true} == M_{\false}$, which must be some form of ex-falso. \textsc{Ask}-$i$ cannot be used in stead of \textsc{Ask} either.

\section{Logical relations}

\subsection{System T extension}

To get a hang of $\digamma$ and logical relations I started by studying a extension of system with $\digamma$

\section{Meta-informations}

\subsection{Time expenditure}


\subsection{Difficulties}

The subject is rather vast and a bit unclear.

Doing logical relations for MLTT is a large task, even before adding sheaves. My next attempt will probably start from logrel rocq insted of nothing

%\subsection{Activities}

\section{Conclusion}



\newpage

\appendix
\appendixname

\section{Dummy}

\printbibliography
\end{document}