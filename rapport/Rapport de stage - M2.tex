\documentclass[11pt]{article}
\usepackage{graphicx} % Required for inserting images
\usepackage[a4paper, lmargin = 1cm, rmargin =1cm, tmargin = 1cm, bmargin = 2cm]{geometry}


\usepackage{tikz}
\usetikzlibrary{cd}
\usepackage{quiver}

\usepackage[sorting=none]{biblatex}
\addbibresource{reference.bib}


\usepackage{mathrsfs}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage[T1]{fontenc}
\usepackage{euscript}

\usepackage{listings}

\usepackage{adjustbox}

\usepackage{color}


\usepackage{semantic}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{ndefinition}[theorem]{Not-a-Definition}

\DeclareMathOperator{\colim}{colim}
\DeclareMathOperator{\Prop}{\mathsf{Prop}}
\DeclareMathOperator{\SProp}{\mathsf{SProp}}
\DeclareMathOperator{\Type}{\mathsf{Type}}
\DeclareMathOperator{\ask}{\mathsf{ask}}
\DeclareMathOperator{\bind}{\mathsf{bind}}
\DeclareMathOperator{\Inductive}{\mathsf{Inductive}}
\DeclareMathOperator{\ret}{\mathsf{ret}}
\DeclareMathOperator{\rec}{rec}
\DeclareMathOperator{\ind}{ind}
\DeclareMathOperator{\ctx}{\mathsf{ctx}}
\DeclareMathOperator{\Typ}{\mathsf{Typ}}
\DeclareMathOperator{\Trm}{\mathsf{Trm}}
\DeclareMathOperator{\true}{\mathsf{tt}}
\DeclareMathOperator{\false}{\mathsf{ff}}
\DeclareMathOperator{\mtrue}{\mathfrak{tt}}
\DeclareMathOperator{\mfalse}{\mathfrak{ff}}
\DeclareMathOperator{\neu}{Ne}


\newcommand{\ovarr}{\overrightarrow}
\newcommand{\ovl}{\overline}
\newcommand{\omlim}{A_0+\sum\limits_{i\geq 1}\ovl A_i}

\newcommand{\0}{\mathbf{0}}
\newcommand{\1}{\mathbf{1}}
\newcommand{\nat}{\mathbf{N}}
\newcommand{\mnat}{\mathfrak{N}}
\newcommand{\bool}{\mathbf{B}}
\newcommand{\mbool}{\mathfrak{B}}
\newcommand{\C}{\mathbf{C}}
\newcommand{\D}{\mathcal{D}}
\newcommand{\SBS}{\mathbf{SBS}}

\newcommand{\Gram}{\mathsf{G}}
\newcommand{\mono}{\rightarrowtail}
\newcommand{\omop}{\omega^{op}}
\newcommand{\omopch}{\Theta}
\newcommand{\omch}{\Omega}
\newcommand{\Dist}{\mathsf{Dist}}
\newcommand{\gd}{\dot {\mathbf{Fun}}}
\newcommand{\colomf}[1]{\varinjlim\circ\omch_{#1}^{(-)}}
\newcommand{\colom}[2]{\varinjlim(\omch_{#1}^{#2})}
\newcommand{\lcontext}{\Gamma}
\newcommand{\rcontext}{\Delta}
\newcommand{\lvar}{\gamma}
\newcommand{\rvar}{\delta}

\newcommand{\tctx}{\Gamma}
\newcommand{\tvar}{\gamma}
\newcommand{\diag}{\Delta}
\newcommand{\DThunk}{\mathsf{Dist}}

\newcommand{\Unit}{\mathsf{Unit}}
\newcommand{\Bool}{\mathsf{Bool}}
\newcommand{\Real}{\mathsf{Real}}
\newcommand{\Nat}{\mathsf{Nat}}
\DeclareMathOperator{\List}{\textsf{List}}
\newcommand{\Stream}{\textsf{Stream}}

\newcommand{\Wf}{\textsf{well-formed}}
\newcommand{\slvl}{\mathbf{s}}
\newcommand{\llvl}{\mathbf{l}}
\newcommand{\fctx}{\mathcal{L}}

\newcommand{\rocq}{\textsc{Rocq}}

\mathlig{<-}{\leftarrow}
\mathlig{->}{\to}
\mathlig{|->}{\mapsto}
\mathlig{=>}{\Rightarrow}
\mathlig{|-}{\vdash}
\mathlig{||-}{\Vdash}
\mathlig{[|}{\llbracket}
\mathlig{|]}{\rrbracket}

\mathlig{==}{\equiv}

\reservestyle{\command}{\mathsf}
\command{inl,inr,wrap,roll,rec,corec,as,match,return,let,in,sample,on,do}


% Distributions in programming language
\newcommand{\Uniform}{\mathsf{uniform}}


\title{Internship report M2\\  Non-singleton Elimination\\}
\author{\textbf{Soudant L\'eo}, supervised by \textbf{Pierre-Marie P\'edrot}, Galinette team at LS2N}
\date{2025}


\begin{document}


\maketitle
\newpage


\subsection*{General context}
To efficiently formalise mathematics we need strong permissive theories.
When attempting to mechanising proofs, however, strong computational properties, like typing decidability, are also expected.
Studying the computational contents of sheaves could allow to emulate forcing directly in type theory, but also to bring a computational content to the axiom which the theory forces.
Thierry Coquand published a few papers on the computational aspect of forcing, Vincent Rahli studied effectful, though undecidable, type theory based on sheaves.
Martin Baillon used a similar theory to show a continuity result on the cantor space \cite{baillon:tel-04617881}.
\subsection*{Research problem}
An element of a topological sheaf may be defined over an open set whenever it is defined on a cover of that open set, so long as they are compatible over the intersections.
We hope to be able to do something similar in a type theory, where open sets correspond to proof irrelevant propositions.
This requires special attention to the compatibility condition~: when a disjunction covers a proposition, it could be possible to eliminate from this disjunction to create a term in any type whenever compatible marginal terms are found.
\subsection*{Your contribution}
We have proved using \rocq\ that a system T variant with a part of the wanted features normalises. Since the proof was done using logical relations, a few other results should be within reach. I also have a model in \rocq\ where types are interpreted as sheaves, although some other variant probably existed before.
\subsection*{Arguments supporting its validity}
The type theory developped by Martin Baillon, which we aim to generalise, proved continuity of all functional $(\nat -> \bool) -> \bool$.
We hope to find other similar results at term.
Forcing has also been a very fruitful method in term of showing consistency of added principle.
\subsection*{Summary and future works}
We will refine the type theory further as well as study other instances similar to the one Martin Baillon studied.
We should also make a fork of the logrel \rocq\ project, and adapt it to show the good properties of any such theory.
\newpage
\tableofcontents
\newpage

\subsection*{Outline}

In section \ref{TT} we explain what type theory is and detail the basic type theory we will study. Section \ref{Sheaves} present the construction we would like to make appear in type theory, and why we think it is possible and useful. Section \ref{Models} present work done on models of type theory, though the important part is precisely the model of sheaf, since its theory is what we ar etrying to build syntactically. Section \ref{ShTT} exposes two sheaf theories, one which comes from previous work and is an important inspiration, and the other which is a prototype of a generalisation. The last section, section \ref{LogRel}, uses the recipe of logical relation to make a proof of concept using a weaker theory, which normalises.

\section{Type theory}\label{TT}

Type theory is a manner of formalising mathematics with a very different design from set theory, and quite a bit closer in structure to a purely logical system like natural deduction. They are also more adapted to mechanising proof than ZFC.

Our meta-theory is alike a type theory, in which 
\begin{itemize}
    \item $\mnat$ denotes its natural numbers type
    \item $\mbool$, $\mtrue$ and $\mfalse$, its boolean type and its two constants
    \item $\Pi$, $\lambda$ and concatenation for its dependent function type
    \item $\Sigma$, $(\_,\_)$, $\mathfrak{p}_1$, $\mathfrak{p}_2$ its dependent product type, pairs and projections, with $\eta$-expansion ($w$ convertible to $(\mathfrak{p}_1 w, \mathfrak{p}_2 w)$).
    \item $\Type$ its universe, with levels left implicit.
\end{itemize}

\subsection{MLTT}
We present a variant of MLTT (Martin-Löf Type Theory), a very standard type theory.

This will give hints as to how our meta-theory work, give a precise reference point for when talking about MLTT, and most importantly, since one of our end goal is to provide an extension of MLTT, describe the first rules of the extension.

This variant will feature dependent function types, universes, and, as positive types, natural numbers and an empty type.

We give ourself a poset of universe levels $\ell$. It may be thought of as $\mnat$, however, for any proof in \rocq, we will need to pick out a finite poset, most likely "$0 < 1$".

We add a type $\nat$ of natural numbers and an empty type $\bot$ as positive types, instead of the heavy syntax of a general inductive type.
They both implement large elimination, which means, in particular, that their induction principle can be used to construct functions returning types, like $\lambda A n, A^n$, in presence of a binary product.

We ignore any issue that could stem from bound variables, and assume different binders use variables different from one another and from free variables.

With terms~:

$$ M,N ::= x \mid \lambda x. M \mid MN \mid 0 \mid S \mid \nat_{\rec} \mid \bot_{\rec} \mid \nat \mid \bot \mid \Pi x :A.B \mid \square_\ell $$


Contexts~:
$$ \tctx ::= \tctx, x : A \mid \cdot $$

We finally give rules for conversion and well formation of contexts. Typing is given by self-conversion, a term $M$ is of type $A$ in context $\Gamma$ whenever $\Gamma |- M == M : A$ is derivable.
$$
    \inference[\textsc{Wf-Empty}]{}{\cdot |- \Wf} \qquad
    \inference[\textsc{Wf-Ext}]{\tctx |- A == A & \tctx |- \Wf}{ \tctx, x : A |- \Wf}
$$
$$
    \inference[\textsc{Int-Typ}]{\tctx |- \Wf}{\tctx |- \nat == \nat : \square_\ell} \qquad
    \inference[\textsc{Emp-Typ}]{\tctx |- \Wf}{\tctx |- \bot == \bot : \square_\ell}
$$
$$
    \inference[\textsc{Fun-Typ}]{\tctx |- A == A' : \square_\ell & \tctx, x : A |- B == B' : \square_{\ell'} & \ell \leq \ell'' & \ell' \leq \ell''}{\tctx |- \Pi x  : A, B == \Pi x: A', B' : \square_{\ell''}} \qquad
    \inference[\textsc{Typ-Typ}]{\tctx |- \Wf & \ell < \ell' }{\tctx |- \square_\ell == \square_\ell: \square_{\ell'}}
$$


$$
    \inference[\textsc{Fun-Intro}]{\tctx, x : A |- M == M' : B &\tctx |- A == A : \square_\ell}{\tctx |- \lambda x. M == \lambda x. M' : \Pi x : A, B} \quad
    \inference[\textsc{Fun-Elim}]{\tctx |- M == M' : \Pi x:A, B& \tctx |- N == N' : A}{\tctx |- MN == M'N' : B(N/x)}
$$

$$
    \inference[\textsc{Axiom}]{\tctx |- \Wf & x : A \in \tctx }{\tctx |- x == x : A} \qquad
    \inference[\textsc{Beta}]{\tctx, x : A |- M == M' : B & \tctx |- N == N' : A}{\tctx |- (\lambda x. M)N == M'(N'/x) : B(N/x)}
$$

$$
    \inference[\textsc{Int-Zero}]{\tctx |- \Wf}{\tctx |- 0 == 0 : \nat} \qquad
    \inference[\textsc{Int-Succ}]{\tctx |- \Wf}{\tctx |- S == S : \nat -> \nat}
$$

$$
    \inference[\textsc{Int-Rec}]{\tctx |- \Wf}{\tctx |- \nat_{\rec} == \nat_{\rec} : \Pi A : \nat \to \square_\ell, A 0 \to \left(\Pi n:\nat, A n \to A (S n)\right) \to \Pi n :\nat, A n}
$$


$$
    \inference[\textsc{Int-Rec-Zero}]{\tctx |- A == A : \nat -> \square_\ell & \tctx |- N_0 == N'_0 == A 0\\ \tctx |- N_S == N_S : \Pi n:\nat, A n -> A(S n)}{\tctx |- \nat_{\rec} A N_0N_S0 == N'_0 : A 0}
$$
$$
    \inference[\textsc{Int-Rec-Succ}]{\tctx |- A == A' : \nat -> \square_\ell & \tctx |- N_0 == N'_0 == A 0\\ \tctx |- N_S == N'_S : \Pi n:\nat, A n -> A(S n) & \tctx |- N == N' :\nat}{\tctx |- \nat_{\rec} A N_0N_S (S N) == N'_S N' (\nat_{\rec}A' N'_0 N'_S N') : A (S N)}
$$


$$
    \inference[\textsc{Emp-Rec}]{\tctx |- \Wf}{\tctx |- \bot_{\rec} == \bot_{\rec} : \Pi A : \bot \to \square_\ell,\Pi e :\bot, A e}
$$

$$
    \inference[\textsc{Sym}]{\tctx |- M == M' : A}{\tctx |- M' == M : A} \qquad
    \inference[\textsc{Trans}]
    {\tctx |- M == M' :A & \tctx |- M' == M'' : A}{\tctx |- M == M'' : A}
$$

$$
    \inference[\textsc{Conv}]
    {\tctx |- M == M' :A & \tctx |- A == A' : \square_\ell}{\tctx M ==M' : A'}
$$

However, it is useful to consider the extension with a type of booleans $\bool$, with new terms~:
 $$ M,N ::= \dots \mid \bool\mid \bool_{\rec}\mid \true\mid \false $$

 And conversion rules

$$
    \inference[\textsc{Bool-True}]{\tctx |- \Wf}{\tctx |- \true == \true : \bool} \qquad
    \inference[\textsc{Bool-False}]{\tctx |- \Wf}{\tctx |- \false == \false : \bool}
$$

$$
    \inference[\textsc{Bool-Rec}]{\tctx |- \Wf}{\tctx |- \bool_{\rec} == \bool_{\rec} : \Pi A : \bool \to \square_\ell, A \true \to A\false \to \Pi b :\bool, A b}
$$


$$
    \inference[\textsc{Bool-Rec-True}]{\tctx |- A == A : \bool -> \square_\ell \\ \tctx |- M_{\true} == M'_{\true} == A {\true} & \tctx |- M_{\false} == M_{\false} : A \false}{\tctx |- \bool_{\rec} A M_{\true} M_{\false} \true == M'_{\true} : A \true}
$$
$$
    \inference[\textsc{Bool-Rec-False}]{\tctx |- A == A : \bool -> \square_\ell \\ \tctx |- M_{\true} == M_{\true} == A \true & \tctx |- M_{\false} == M'_{\false} : A \false}{\tctx |- \bool_{\rec} A M_{\true} M_{\false} \false == M'_{\false} : A \false}
$$

\subsection{System T}
To verify that the features we would add made some amount of sense, we studied them first in system T.
System T has no universes, no dependent function types, and keeps types and terms well-separated.
This makes applying the proof technique we used, logical relations, much simpler.
We use the following variant~:

With types~:

$$ A ::= A -> A \mid \nat \mid \bot $$

Terms~:

$$ M,N ::= x \mid \lambda x. M \mid MN \mid 0 \mid S \mid \nat_{\rec} \mid \bot_{\rec} $$


Contexts~:
$$ \tctx ::= \tctx, x : A \mid \cdot $$

And conversion rules~:


$$
    \inference[\textsc{Fun-Intro}]{\tctx, x : A |- M == M' : B }{\tctx |- \lambda x. M == \lambda x. M' : A -> B} \qquad
    \inference[\textsc{Fun-Elim}]{\tctx |- M == M' : A -> B& \tctx |- N == N' : A}{\tctx |- MN == M'N' : B}
$$

$$
    \inference[\textsc{Axiom}]{x : A \in \tctx }{\tctx |- x == x : A} \qquad
    \inference[\textsc{Beta}]{\tctx, x : A |- M == M' : B & \tctx |- N == N' : A}{\tctx |- (\lambda x. M)N == M' : B}
$$

$$
    \inference[\textsc{Int-Zero}]{}{\tctx |- 0 == 0 : \nat} \qquad
    \inference[\textsc{Int-Succ}]{}{\tctx |- S == S : \nat -> \nat}
$$

$$
    \inference[\textsc{Int-Rec}]{}{\tctx |- \nat_{\rec} == \nat_{\rec} : A \to \left(\nat -> A -> A \right) -> \nat -> A}
$$


$$
    \inference[\textsc{Int-Rec-Zero}]{\tctx |- N_0 == N'_0 == A\\ \tctx |- N_S == N_S : \nat -> A  -> A}{\tctx |- \nat_{\rec} N_0N_S0 == N'_0 : A}
$$
$$
    \inference[\textsc{Int-Rec-Succ}]{\tctx |- N_0 == N'_0 == A\\ \tctx |- N_S == N'_S : \nat -> A  -> A & \tctx |- N == N' :\nat}{\tctx |- \nat_{\rec} N_0N_S (S N) == N'_S N' (\nat_{\rec}N'_0 N'_S N') : A}
$$


$$
    \inference[\textsc{Emp-Rec}]{}{\tctx |- \bot_{\rec} == \bot_{\rec} : \bot -> A}
$$

$$
    \inference[\textsc{Sym}]{\tctx |- M == M' : A}{\tctx |- M' == M : A} \qquad
    \inference[\textsc{Trans}]
    {\tctx |- M == M' :A & \tctx |- M' == M'' : A}{\tctx |- M == M'' : A}
$$

Typing rules are encoded as self-conversion, and difficulties surrounding variables are ignored.

\section{Sheaves}\label{Sheaves}

Since we refer to some of the more historical notion of sheaves and since topoi are a set theorist approach of type theory, the meta-theory and language of subsections \ref{topsheaves}, \ref{KripkeBeth} and  \ref{topoi} are more alike set theory.
Since the definition are presented by way of example, this should not be an issue.

\subsection{Sheaves on topological spaces}\label{topsheaves}

While sheaves on topological space are the hardest form of sheaves to connect to the $(I,O)$-sheaves we study (defined in \ref{shfinTT}), we find that they offer a clearer insight on how sheaves are going to be used than sheaves on a grothendieck topology do, and as such present the first and not the second in detail.
Treating proof irrelevant proposition as subset of a space is a notion we like to keep in mind.

We fix a topological space $X$, in this case presheaves on that space are presheaves on the category underlying its poset of open subsets. More precisely~:

\begin{definition}[Presheaf on a topology]
    A \emph{presheaf} $P$ is given by
    \begin{itemize}
        \item For every open $U \in \mathcal{O}(X)$, a set $P(U)$ of \emph{sections}
        \item For every open $U$, section $s\in P(U)$, and open subset $V\subseteq U$, a \emph{restriction} $s|_V\in P(V)$
        \item If $s\in P(U)$, $s|_U = s$
        \item If $s\in P(U)$, $W\subseteq V \subseteq U$, $(s|_V)|_W = s|_W$
    \end{itemize}
\end{definition}
The $\lambda (s\in P(U)), s|_V : P(U) -> P(V)$ function is the function $P(f)$ necessary to construct the functor $P : \mathcal{O}(X)^{op} -> \mathbf{Set}$, justifying the use of the same term \guillemotleft~presheaf \guillemotright\ here and in the categorical context.

In the context of topologies, sheaves are simply refinements of presheaves~:
\begin{definition}[Sheaf on a topology]
    A \emph{sheaf} $\mathcal{F}$ is a presheaf such that given any open  $U$ and family of open $(U_i)_i$ such that $U = \bigcup_i U_i$, there is a bijection between~:
    \begin{itemize}
        \item Sections $s$ of $U$
        \item \emph{Compatible} families $(s_i\in \mathcal{F}(U_i))_i$ of sections where $s_i|_{U_i\cap U_j} = s_j|_{U_i\cap U_j}$
    \end{itemize}
    where the forward direction is given by $s \mapsto (s|_{U_i})_i$.
\end{definition}

Using natural transformations as arrows, both sheaves and presheaves over a topology form a category, respectively $\widehat{\mathcal{O}(X)}$ and $\mathbf{Sh}(X)$.
\begin{lemma}[Sheafification]
    The inclusion functor of sheaves into presheaves $\mathbf{Sh(X)} -> \widehat{\mathcal{O}(X)}$ has a left \emph{sheafification} adjoint.
\end{lemma}

This adjoint can be constructed using the plus construction $P \mapsto P^{+}$, which gives the presheaf of compatible families up to refinement.
It always yields a sheaf when applied twice, and stabilises at this point \cite{maclane2012sheaves}.

Since the definitions only access the open subsets and not the points of the space, they can be extended to \emph{locales}, that is, posets with finite meets and arbitrary joins satisfying the infinite distributive law. As far as the reader is concerned, this only means $\vee,\wedge$ and $\leq$ will be used instead $\cup,\cap$ and $\subseteq$. We will stick with calling their elements opens, however.

\subsection{Kripke and Beth semantics}\label{KripkeBeth}
As a first taste of the logical content of presheaves and sheaves, we present Kripke and Beth models for proposititional intuitionistic logic.


To construct a Kripke model, we consider a locale (or in general, a small category). We consider a set of proposititional variables and to $P$ one of them, associate a downward closed set of opens, or \emph{sieve} $S_P$.

We can then define $U ||- \phi$, meaning $U$ forces $\phi$, by induction on the structure of $\phi$.
\begin{itemize}
    \item $U ||- P$ iff for all $V\leq U$, $V \in S_P$
    \item $U ||- \phi \wedge \psi$ iff for all $V\leq U$, $V ||- \phi$ and $V ||- \psi$
    \item $U ||- \phi => \psi$ iff for all $V \leq U$, if $V ||- \phi$ then $V ||- \psi $
    \item $U ||- \phi \vee \psi $ iff for all $V \leq U$, $V ||- \phi$ or $V ||- \psi$
\end{itemize}
We can then prove that for all $\phi$, $U||-\phi$ iff for all $V \leq U$, $V ||- \phi$, making all cases but $ => $ become degenerate. For example, $U ||- \phi \wedge \psi$ iff for all $V \leq U$, $ V||- \phi$ and $V ||- \psi$ iff $U||- \phi$ and $U||- \psi$. This recovers the more common definition.

We note that by using the poset of contexts, Kripke models done with small categories are (only classicaly) complete for propositional intuitionistic logic.

Sheaves themselves yield a more general kind of model, Beth models.

For every propositional variable $P$, $S_P$ must now be stable under union, since we introduce \emph{covers} of an open, and says $(U_i)_i$ covers $U$ whenever $U = \bigvee U_i$. The forcing statement $U ||- \phi$ is now defined as follows~:
\begin{itemize}
    \item $U ||- P$ iff for all $V \leq U$ there exists $(V_i)_i$ covering $V$, such that for all $i$, $V_i \in S_P$
    \item $U ||- \phi \wedge \psi$ iff for all $V \leq U$ there exists $(V_i)_i$ covering $V$, such that for all $i$, $V_i ||- \phi$ and $V_i ||- \psi $.
    \item $U ||- \phi \vee \psi $ iff for all $V \leq U$ there exists $(V_i)_i$ covering $V$, such that for all $i$, $V_i ||- \phi$ or $V_i ||- \psi $.
    \item $U ||- \phi => \psi $ iff for all $V \leq U$ there exists $(V_i)_i$ covering $V$, such that for all $i$, if $V_i ||- \phi$ then $U_i ||- \psi $.
\end{itemize}
Now it can also be proven that $U ||- \phi$ iff there exists $(U_i)_i$ covering $U$, such that for all $i$, $U_i||- \phi$, and the above degenerates into~:
\begin{itemize}
    \item $U ||- P$ iff $U \in S_P$
    \item $U ||- \phi \wedge \psi$ iff $U ||- \phi$ and $U ||- \psi $.
    \item $U ||- \phi \vee \psi $ iff there exists $(U_i)_i$ with $U = \bigvee_i U_i$, such that for all $i$, $U_i ||- \phi$ or $U_i ||- \psi $.
    \item $U ||- \phi => \psi $ iff for all $V \leq U$, if $V ||- \phi$ then $V ||- \psi $.
\end{itemize}

They are other variant of Beth semantics, relying on different notion of \emph{cover} in small categories.

Both Kripke and Beth model can be extended to interpret quantifiers, and even further, since some of them, depending on their base category and notion of cover, even interpret set theory entirely. Notably the completely degenerate 1 object category, which recovers the standard model (interpreting sets as sets\dots), and models which negates the axiom of choice or the continuum hypothesis.

\subsection{Topoi and sheaves in topoi}\label{topoi}

Those extended models emerge because presheaves and sheaves form topoi. Looking at topoi allows separation of the notion of sheaves from that of presheaves.

Proofs, results and details for this section can often be found in \emph{Sheaves in geometry and logic: A first introduction to topos theory} by Saunders Maclane and Ieke Moerdijk \cite{maclane2012sheaves}.

\begin{definition}[Subobject]
    In a category, a \emph{subobject} of $X$ is an equivalence class of monomorphism $m : A \mono X$, where the equivalence comes from the preorder where $ m : A \mono X $ is smaller than $ m' : A' \mono X$ when there is a map $f : A -> A'$ with $ m' \circ f = m$.
\end{definition}

We deduce a presheaf $\mathbf{Sub}$ where $\mathbf{Sub}(X)$ is the the set of subobjects of $X$, and $\mathbf{Sub}(f) : \mathbf{Sub}(Y) -> \mathbf{Sub}(X)$ sends $m : A -> Y$ to its pullback by $f : X -> Y $. 

\begin{definition}[Topos]\label{topos}
    A \emph{topos} is a cartesian closed category with all finite limits and a suboject \emph{classifier} $\Omega$ and an isomorphism $\mathbf{Sub}(X)\cong \mathbf{Hom}(X, \Omega)$ natural in $X$.
\end{definition}

We note that topoi also have finite colimits.

Topoi form a class of models of some kind of type theory.
However, this type theory has equality reflection, proposititional extensionnality, strict propositions and the axiom of unique choice. This properties form a very strong, but also undecidable, system. In particular they are no known type theory with both unique choice and strict propositions which preserves canonicity and decidability of type-checking. They also have no universe in general, which, on the other hand, makes them very weak.


To give a few examples of topoi, $\mathbf{Set}$ is a topos, and given a topos $\mathcal E$, $\mathcal{E}/X$, the category of maps with codomain $X$ and commuting triangles, as well as $\mathcal{E}^{\mathbf{C}^{op}}$, the category of contravariant functors from a small category $\mathbf{C}$ and natural transformation, are all topoi. In particular categories of presheaves are topoi, and their internal language are extensions of Kripke models. The categories of sheaves over topological spaces also form topoi, and their internal language are extensions of Beth models.

The subobject classifier $\Omega$ is equipped with an internal meet-semilattice structure inherited from the meet-semilattice structure on each $\mathbf{Sub}(X)$, which is natural in $X$.

\begin{definition}[Lawvere-Tierney topology]
    A \emph{Lawvere-Tierney topology} is a left exact idempotent monad $j$ on the internal meet-semilattice on $\Omega$.
\begin{itemize}
    \item $ id_\Omega \leq j $,
    \item $ j\circ j \leq  j$
    \item $ j \circ \wedge = \wedge \circ j\times j$
\end{itemize}
\end{definition}

From a topology $j$ we extract a closure operator $J_X$ of $\mathbf{Sub}(X)$ for any $X$.
\begin{definition}[Dense subobject]
    A suboject $U$ of $X$ is dense if $J_XU  = X$
\end{definition}

A topology can be lifted to a left exact idempotent monad on the entirety of the topos, the sheafification monad.

\begin{definition}[$j$-Sheaf in topos]
    An object $F$ is a $j$-\emph{sheaf} in a topos if for any dense subobject $U$ of any object $X$, the morphism $\mathbf{Hom}(X, F) -> \mathbf{Hom}(U, F)$ obtained by precomposition is an isomorphism.
\end{definition}

%A $j$-Sheaf is up to isomorphism the result of sheafifying an object, as such, we can deduce that .

Just like with topological sheaves, the full sub-category of $j$-Sheaves in a topos $\mathcal{E}$ forms a topos $\mathbf{Sh}_j(\mathcal{E})$. Note that this definition of sheaves makes no reference to presheaves, however, they do still specialise to topological presheaves.

In the topos of presheaf over $X$, elements of $\Omega$ are downward closed sets of open. To recover topolgical sheaves, the $j$ operator must send such set to the set of sub-opens of their union \emph{i.e} sub-opens which can be covered by them. A subobject $A$ of $P$ is then dense if for every open $U$ and every section $s$ of $P(U)$, there is a family of opens and sections $s_i\in U_i$ which can be glued back into $s$, \emph{i.e.} $U = \bigvee U_i$ and $s_i = s|_{U_i}$. Although, to recover the earlier sheaf definition, one can simply look at presheaves $P$ where $P(U)$ has at most one element, since morphisms out of these presheaves directly yield compatible families.

And just like with topological presheaves, we can define sheafification.

\begin{lemma}
    The inclusion functor from $j$-sheaves in a topos $\mathcal{E}$ to the topos $\mathcal{E}$ has a left \emph{sheafification} adjoint.
\end{lemma}

As announced, it is an idempotentt monad.

\subsection{Geometric formulas}
In the litterature around sheaves and forcing, we find the following definitions.
\begin{ndefinition}
A \emph{geometric formula} is a formula built from $\exists, \wedge,\bigvee$, and atomic formulas.
\end{ndefinition}
\begin{ndefinition}
A \emph{geometric implication} is a formula of shape $\forall \overrightarrow{x}, \phi(\overrightarrow{x}) -> \psi(\overrightarrow{x})$, where $\phi$ and $\psi$ are geometric.
\end{ndefinition}
\begin{ndefinition}
    A \emph{geometric theory} is a set of geometric implication.
\end{ndefinition}
We rather use the following definition

\begin{definition}
    A \emph{geometric formula} is a formula of the form $$\bigwedge_{i : I}\left(\forall \overrightarrow{x}, \bigwedge_{j : J_i} O_{i,j}(\overrightarrow{x}) -> \bigvee_{k : K_i}\exists \overrightarrow{y},\bigwedge_{l : L_{i,k}} Q_{i,k,l}(\overrightarrow{x},\overrightarrow{y})\right)$$
    Where $O_{i,j}$ and $Q_{i,k,l}$ are atomic formulas, and both every $J_i$ and every $L_{i,k}$ are finite.
\end{definition}

Every \guillemetleft~geometric theory~\guillemetright\ can be written as a single geometric formula.

We'd like to note that they define covers as they can be read as saying that some intersection of atoms can be covered by a family of intersection of atoms, and that they may be integrated in a deduction system as~: 
$$
    \inference[\textsc{Geo}-$i$]{Q_{i,1,1}(\overrightarrow{x},\overrightarrow{t_1})\dots Q_{i,1,m_{i,1}}(\overrightarrow{x},\overrightarrow{t_1}),\Gamma|-\mathcal{J}\ \cdots\ Q_{i,p_i,1}(\overrightarrow{x},\overrightarrow{t_{p_i}})\dots Q_{i,p_i,m_{i,p_i}}(\overrightarrow{x},\overrightarrow{t_{p_i}}),\Gamma|-\mathcal{J}}{O_{i,1}(\overrightarrow{x}),\dots O_{i,n_i}(\overrightarrow{x}),\Gamma|-\mathcal{J}}
$$

\subsection{Sheaves in type theory}\label{shfinTT}

Consider a type theory with a notion of proof irrelevant propositions $\Prop$, \emph{e.g.} book-HoTT with mere propositions, or \rocq\ with $\SProp$.

In this case, a Lawvere-Tierney topology may be similarily defined, as a monad:
\begin{itemize}
    \item $\mathsf{J} : \Prop -> \Prop$
    \item $\eta : \Pi (P:\Prop).P -> \mathsf{J}\ P$
    \item $\bind : \forall (P Q: \Prop). \mathsf{J}\ P -> (P -> \mathsf{J}\ Q) -> \mathsf{J}\ Q$
\end{itemize}

Then a sheaf is just a type $T$ with 
\begin{itemize}
    \item A map $\ask_T : \Pi (P:\Prop).\ \mathsf{J}\ P -> (P -> T) -> T$
    \item A coherence $\varepsilon_T : \Pi (P:\Prop)\ (j : \mathsf{J}\ P)\ (x:T).\ \ask_T\ P\ j\ (\lambda p:P.x) = x$
\end{itemize}

In this context, sheafification doesn't exist in general, but if the meta-theory admits quotient inductive types, it can then be defined as follow~:

$$
\begin{array}{l}
    \Inductive\ \mathcal{S}_{\mathsf{J}}\ T : \Type := \\
    \mid \ret : T -> \mathcal{S}_{\mathsf{J}}\ T\\
    \mid \ask : \Pi (P:\Prop). \mathsf{J}\ P -> (P -> \mathcal{S}_{\mathsf{J}}\ T) -> \mathcal{S}_{\mathsf{J}}\ T\\
    \mid \varepsilon : \Pi (P:\Prop)\ (j : \mathsf J\ P)\ (x : \mathcal{S}_{\mathsf{J}}\ T). \ask\ P\ j\ (\lambda p:P. x) = x
\end{array}
$$

The induction principle is then about as powerful as an adjunction could be, as such we will chose not to define the amount of category theory necessary to formulate the later.

We note that by taking $I := \Sigma (P:\Prop). \mathsf{J}\ P$ and $O:=\lambda (P,j).P$, the definition of a sheaf becomes a special case of the following~:
\begin{definition}\label{IOshf}
    A \emph{sheaf} or \emph{$(I,O)$-sheaf}, is given by
\begin{itemize}
    \item A type $T$
    \item A map $\ask_T : \Pi (i:I), (O\ i -> T) -> T$
    \item A coherence map $\varepsilon_T : \Pi(i:I)\ (x:T), \ask_T\ i\ (\lambda o:O\  i.x) = x$
\end{itemize}

\end{definition}
Where $I$ is a type and $O$ a family of propositions.

$(I,O)$-Sheafification can be defined similarily. This definition is marginally simpler, and make sheaves appear as quotient dialogue trees, hence why we will henceforth consider \emph{$(I,O)$-sheaves} instead of \emph{$\mathsf{J}$-sheaves}.

It is also possible to see geometric formulas as being of the form $\Pi i : I, O i$, after hefty uncurrying. As such, we will use them to describe our sheaves. However, not all sheaves can be described this way, in particular $\lnot\lnot$ is a Lawvere-Tierney topology which has no satisfying geometric formula.

\section{Models}\label{Models}

\subsection{Categories with family}

A common mean of constructing models of type theory is through categories with families.

They are constituted of~:
\begin{itemize}
    \item A category of contexts and substitutions~:
    $$ \begin{array}{rl}
        \mathsf{Ctx} :& \Type\\
        \mathsf{Sub} :& \mathsf{Ctx} -> \mathsf{Ctx} -> \Type\\
        \mathsf{Id} :& \Pi (\Gamma:\mathsf{Ctx}), \mathsf{Sub}\ \Gamma\ \Gamma\\
        &\dots
    \end{array}$$
    \item For every context a type of inner types, and for every context and inner type in that context, a type of terms, both accompanied by the action of the substitution upon those, and the corresponding rules.
    $$ \begin{array}{rl}
        \Typ :& \mathsf{Ctx} -> \Type\\
        \Trm :& \Pi (\Gamma : \mathsf{Ctx}),\Typ \Gamma -> \Type\\
        A[\sigma] :&\Typ\ \Gamma \text{ whenever } A : \Typ \Delta \text{ and } \sigma : \mathsf{Sub}\ \Gamma\  \Delta\\
        t[\sigma] :&\Trm\ \Gamma\ A[\sigma]\text{ whenever } t : \Trm\ \Delta\ A \text{ and } \sigma : \mathsf{Sub}\ \Gamma\  \Delta\\
        \_:& A[\mathsf{Id}] = A\\
        &\dots
    \end{array} $$
    \item A way to append a type to a context, substitution weakening, lifting and extension.
    $$ \begin{array}{rl}
        \Gamma ; A :& \mathsf{Ctx} \text{ whenever } A : \Typ \Gamma\\
        &\dots
    \end{array}$$
\end{itemize}
They may be complemented by~:
\begin{itemize}
    \item Dependent function inner types, with their constructor, eliminator, and their substitution laws.
    $$
        \begin{array}{rl}
            \mathsf{Pi}\ A\ B:& \Typ\Gamma \text{ whenever } A : \Typ \Gamma \text{ and } B : \Typ (\Gamma;A)\\
            \mathsf{Abs}\ t :& \Trm\ \Gamma\ (\mathsf{Pi}\ A\ B) \text{ whenever } t : \Trm\ (\Gamma;A)\ B\\
            \mathsf{App}\ t\ u:& \Trm\ \Gamma\ B[u] \text{ whenever } t : \Trm\ \Gamma\ (\mathsf{Pi}\ A\ B) \text{ and } u : \Trm\ (\Gamma;A)\ B\\
            & \cdots
        \end{array}
    $$
    \item A universe inner type, and its element function and their substitution laws.
    $$
        \begin{array}{rl}
            \mathsf{U}:& \Typ \Gamma\\
            \mathsf{El[A]}:& \Typ \Gamma \text{ whenever } A:\Trm\ \Gamma\ \mathsf{U}\\
            &\cdots
        \end{array}
    $$
    In their presence, some things may be presented as elements of $\Trm\ \Gamma\ \mathsf{U}$ instead of $\Typ\Gamma$.
    \item Some positive types, like a boolean type, its eliminator and constructors, and their substitution laws.
    $$
        \begin{array}{rl}
            \bool:& \Typ \Gamma\\
            \true:& \Trm\ \Gamma\ \bool\\
            \false:& \Trm\ \Gamma\ \bool\\
            \bool_{\rec}\ P\ p_{\true}\ p_{\false}:& \Trm\ \Gamma\ (\mathsf{Pi}\ \bool\ P) \text{ whenever } p_{\true} : \Trm\ \Gamma\ P[\true] \text{ and } p_{\false} : \Trm\ \Gamma\ P[\false]\\
            &\cdots
        \end{array}
    $$
    \item Dependent pair inner types, eliminators, constructors, and laws.
    $$
        \begin{array}{rl}
            \mathsf{Sig}\ A\ B:& \Typ\Gamma \text{ whenever } A : \Typ \Gamma \text{ and } B : \Typ (\Gamma;A)\\
            (a,b) :& \Trm\ \Gamma\ (\mathsf{Sig}\ A\ B) \text{ whenever } a : \Trm\ \Gamma\ A  \text{ and } b : \Trm\ \Gamma\ B[a]\\
            \mathsf{Sig}_{\rec}\ P\ p :& \Trm\ \Gamma\ (\mathsf{Pi}\ (\mathsf{Sig}\ A\ B)\ P) \text{ whenever } p :\Trm\ \Gamma\ P[(a,b)]\\
            &\cdots
        \end{array}
    $$
\end{itemize}

A significant part of my internship was dedicated to contructing models of type theory in \rocq, using categories with families.

The most notable being~:
\begin{enumerate}
    \item A model using dialogue trees.
    \item An exceptional model.
    \item A model using presheaves.
    \item A model using $(I,O)$-sheaves, which requires univalence, and quotient inductive types to model positive types.
\end{enumerate}

None of them completely implement all the feature listed above, but only the model using presheaves has no dependent function type.

\rocq\ served as both the meta-theory and the target.

\subsection{Dialogue trees}

We proceed with introducing these models and their associated structure, starting with dialogue trees.

Given a $I : \Type$ and $O : I -> \Type$, an $(I,O)$-dialogue tree, is a type $A$ together with a map $\Pi i : I, (O\ i-> A) -> A$. More important, maybe, are how free dialogue tree are defined~: 

$$
\begin{array}{l}
    \Inductive\ \mathcal{D}_{I,O}\ T : \Type := \\
    \mid \ret : T -> \mathcal{D}_{I,O}\ T\\
    \mid \ask : \Pi (i : I),(O\ i -> \mathcal{D}_{I,O}\ T) -> \mathcal{D}_{I,O}\ T\\
\end{array}
$$

They encode a fairly large family of monads%, and, notably, the inductive type with only $\ask$ can encode any .
They are quite similar to sheaves, however, unlike sheaves, a model interpreting types as dialogue trees do not require no univalence nor HITs, but cannot implement booleans (or in general, inductive types) as usual.

Instead, they implement them in the way of Baclofen TT, meaning that, using booleans as an example, the eliminator for types $\bool_{\ind} : \Pi P : \square_\ell, P -> P -> \bool -> P $ is separate from the eliminator for type families $\bool_{\rec} : \Pi P : \bool -> \square_\ell, P \true -> P \false -> \Pi b : \bool, \theta_\bool P b$.

$\bool_{\ind}$ behaves like the usual eliminator applied to a constant predicate. $\bool_{\rec}$ involves $\theta_\bool P$, the linearisation of $P$ defined by $\theta_\bool:= \lambda P n, \bool_{\ind} ((\bool ->\square_\ell) -> \square_\ell) (\lambda Q, Q \true) (\lambda Q, Q \false) b P$, or, more clearly, $\theta_\bool P \true := P \true$ and $\theta_\bool P \false :=  P \false$.


While our model doesn't model integers, it should also be possible, with the eliminator for types as $\nat_{\ind} : \Pi P : \square_\ell, P -> (\nat ->P -> P) -> \nat -> P $ and the eliminator for type families as $\nat_{\rec} : \Pi P : \nat -> \square_\ell, P 0 -> (\Pi n :\nat, P n -> P (S n)) -> \Pi n : \nat, \theta_\nat P n$.

$\nat_{\ind}$ also behaves like the usual eliminator applied to a constant predicate, and $\nat_{\rec}$ also involves a linearisation of $P$ named $\theta_\nat P$, defined as $\theta_\nat:= \lambda P n, \nat_{\ind} ((\nat ->\square_\ell) -> \square_\ell) (\lambda Q, Q 0) (\lambda n \theta' Q, \theta' (Q\circ S)) n P$, or, more clearly, $\theta_\nat P 0 := P 0$ and $\theta_\nat P (S n) := \theta_\nat (P\circ S) n$. In particular, they coincide on  integers of the form $S(\cdots (S 0)\cdots)$.

Other writers may swap $\ind$ and $\rec$.

The model took
$$
    \begin{array}{rl}
        \mathsf{Ctx} :=& \Type\\
        \Typ\Gamma :=&\Gamma -> (\Sigma (A : \Type), \Pi(i:I), (O\ i-> A)->A)\\
        \Trm\ \Gamma\ A := & \Pi (\gamma:\Gamma), \mathfrak{p}_1 (A\ \gamma)
    \end{array}
$$
The rest follows. As is the case with the other models here besides presheaves, contexts are just types.
%This is related to the effects added by these theories, which are all call-by-name, meaning they factor through an Eilenberg-Moore category

This models contrasts with how sheaves do not need to weaken the theory down to Baclofen TT to add effects

\subsection{Exceptional}

The exceptional model (for exception type $E$) interprets a type as a pair of a type and a map $E -> A$. It is inconsistent, at least when $E$ is inhabited, however, together with parametricity, a consistent model can be recovered.

This models highlights the importance of computations, since an inconsitent type theory can still be used to state a few thing as long as it computes properly.

\subsection{Presheaves}

The most time consuming model, where neither universes nor dependant function types could be implemented. The main issue is the straightforward implementation is not strict, meaning equalities have to be proven, and transport along them must be handled.

To give the broad strokes of the model, we use the following definition of a category, mostly to name the fields. It must be understood as a record (a fancy $\Sigma$), so the projection are named according to the fields.
$$ \textsf{Cat} := \left\{
    \begin{array}{rl}
        \mathsf{obj} :& \Type\\
        \mathsf{hom} :& \mathsf{obj}->\mathsf{obj}->\Type\\
        \mathsf{id} :& \Pi (X : \mathsf{obj}),\mathsf{hom}\ X\ X\\
        \mathsf{comp} :& \Pi (X Y Z: \mathsf{obj}), \mathsf{hom}\ Y\ Z -> \mathsf{hom}\ X\ Y -> \mathsf{hom}\ X\ Z \\
        &\dots
    \end{array} \right\}
$$

We fix a category $\mathbf{C} : \mathsf{Cat}$, so the first fields of the model are given by~:

$$
    \begin{array}{rl}
        \mathsf{Ctx} :=& 
        \left\{\begin{array}{rl}
            \mathsf{Ctx\_obj} :& \mathsf{obj}\ \C -> \Type\\
            \mathsf{Ctx\_hom} :& \Pi (X Y : \mathsf{obj}\ \C), \mathsf{hom}\ \C\ X\ Y -> \mathsf{Ctx\_obj}\ Y -> \mathsf{Ctx\_obj}\ X\\
            &\dots
        \end{array}\right\}\\
        \Typ\Gamma :=&
        \left\{\begin{array}{rl}
            \mathsf{Typ\_obj} :& \Pi (X : \mathsf{obj})\ \mathsf{Ctx\_obj}\ \Gamma\ X -> \Type\\
            \mathsf{Typ\_hom} :& \Pi (X Y : \mathsf{obj}\ \C)(f:\mathsf{hom}\ \C\ X\ Y)(y : \mathsf{Ctx\_obj}\ \Gamma\ Y),\\ 
            & \quad\mathsf{Typ\_obj}\ Y\ y -> \mathsf{Typ\_obj}\ X\ (\mathsf{Ctx\_hom}\ \Gamma\ X\ Y\ f\ y)\\
            &\dots
        \end{array}\right\}
    \end{array}
$$
Notably, context are presheaves and not just types, and, strictly speaking, types are only presheaves in an empty context.

This model highlights why studying sheaves separately from presheaves is interesting.

\subsection{Sheaves}

The most important one is of course the model using sheaves.

The model requires univalence and used rewrite rules to simulate HIT, which are absent in \rocq 9.0.0.

Types were interpreted as sheaves as described in definition \ref{IOshf}. Product types are relatively easy as an aribtray product of sheaves is still a sheaf. Positives types, in my case boolean, where contructed as the QIT with the same constructor as the original (true and false), together with $\ask$ and $\varepsilon$. The resulting type is equivalent to the sheafification of booleans but does not compute exactly the same.

One of the interest of type theory is that it yield meaningful computations from proof, so we were careful about that.

\section{ShTT}\label{ShTT}
\subsection{Martin Baillon's ShTT}\label{MBshtt}
Our work was meant to generalise the work of Pierre-Marie Pédrot and his past PhD student, Martin Baillon, did in the thesis of the latter \cite{baillon:tel-04617881} and afterwards, which itself follows up on a note from Jaber and Coquand \cite{10.5555/1839560.1839564}. He worked on a roughly similar MLTT extended with boolean and a generic cohen real $\alpha: \nat -> \bool$, where the context was extended with finite knowledge of this function, which allowed $\alpha$ to compute on closed form integers.

The sheaf structure is the one appearing in this geometric formula~:

$$ \left(\bigwedge_{n : \mnat} \top -> (n \mapsto_\alpha \mtrue) \vee (n \mapsto_\alpha \mfalse)\right) \wedge \left(\bigwedge_{n : \mnat} (n\mapsto_\alpha \mtrue) \wedge (n \mapsto_\alpha \mfalse) -> \bot \right)$$

With atoms $n \mapsto_\alpha b$ for all $n : \mnat$ and $b:\mbool$.


The term then extends those of MLTT with only $\alpha$~:
$$ M, N ::= \dots \mid \alpha$$

Together with the usual context, judgments depends on a \emph{forcing context} containing the finite approximation of $\alpha$, given by the following syntax, when $n$ and $b$ an integer and boolean respectively
$$ \fctx ::= \fctx, n \mapsto b \mid \cdot$$
We write $n\mapsto_\fctx b$ when $n\mapsto b$ appears in $\fctx$, and $n\not\mapsto_\fctx$ when neither $n\mapsto \mtrue$ nor $n\mapsto \mfalse$ do.

The type theory has rules~:
$$
    \inference[n]{\fctx,\tctx |- \mathcal{J}_0 & \cdots & \fctx,\tctx |- \mathcal{J}_n}{\fctx,\tctx |- \mathcal{J}}
$$
whenever the following is a rule of MLTT (with booleans)
$$
    \inference[n]{\tctx |- \mathcal{J}_0 & \cdots & \tctx |- \mathcal{J}_n}{\tctx |- \mathcal{J}}
$$
With $\mathcal{J}$ a judgment of conversion or well formation, and $\text{n}$ the name of the rule.

An exception is made for \textsc{Wf-Empty}, which becomes
$$
    \inference[\textsc{Wf-Empty}]{}{\cdot,\cdot |- \Wf}
$$

The new rules, using overlining to turn meta-theoretical integers and booleans into the corresponding terms, are~:
$$
    \inference[\textsc{Wf-Ext-Forc}]{\fctx,\tctx |- \Wf & n\not\mapsto_\fctx}{\fctx, n\mapsto b, \tctx |- \Wf}
$$
$$
    \inference[\textsc{Gen}]{\fctx,\tctx|- \Wf}{\fctx,\tctx |- \alpha == \alpha : \nat -> \bool}
    \qquad
    \inference[\textsc{Ask}]{\fctx,\tctx|- \Wf &n\mapsto_\fctx b}{\fctx, \tctx |- \alpha \ovl n == \ovl b}
$$
$$
    \inference[\textsc{Split}]{\fctx,n\mapsto \mtrue,\tctx |-M == M' :A & \fctx, n\mapsto\mfalse, \tctx |- M == M' : A & n\not\mapsto_\fctx}{\fctx,\tctx |- M == M' : A}
$$

Amongst other thing, this theory can be used to show that from any term $\cdot |- M == M : (\nat -> \bool) -> \nat$ of MLTT, a term $\{M\}$ of MLTT proving its continuity can be constructed, \emph{i.e.} $\cdot |- \{M\} == \{M\} : \mathsf{continuous}\ M$ can be derived.

\subsection{ShTT}

We sought to create a type theory based on general sheaves, based on a simple geometric formula.
As of our latest draft, we use $\bigwedge\limits_{i : I} \left(\top -> \bigvee\limits_{\alpha : A\ i}O_{i,\alpha}\right)$.
It is the simplest one involving branching.

While in \ref{MBshtt} conversion rules could be added, it is imposible without specialising the system and deciding what $O_{i,\alpha}$ means.
We needed to add term by which the sheaf nature of our types would appear.
Since the model of each type was a sheaf, it contained a map $\ask$, which we sought to add to the syntax under the name $\digamma$.
Such map could be obtained in \ref{MBshtt} as $\ask_n T\ t_{\true}\ t_{\false} := \bool_{\rec}\ (\lambda\_.T)\  t_{\true}\ t_{\false}\ (\alpha\ \ovl{n})$.
%At our level of generality, this is all that can be added.

We suppose we have a type $\Omega$ of \emph{atoms}.
We then set a type $I$ with decidable equality, and a (morally pointwise finite) type family $A : I -> \Type$ standing for arities, and finally a family $O : \Pi i:I, A\ i -> \Omega$, writing $O_{i,\alpha}$ instead of $O\ i\ \alpha$ for space concerns.

Those are also the types we use to give the shape of the geometric formula.

The terms extend those of MLTT as follows~:

$$ M, N ::= \dots \mid\digamma_i (M_\alpha)_{\alpha : A\ i}$$

When instanciating with finite $A i$, it would rather be  $\digamma_i M_1 \cdots M_n$.

The forcing contexts $\fctx$ are now subset of $\Omega$ (lists accessed only through whether they include some elements), and never cause ill-formation.

The conversion rules also copy those from MLTT by adding a forcing context as in \ref{MBshtt}, without the \textsc{WF-Empty} exception.

The new conversion rules are as follows~:

$$
    \inference[\textsc{Dig}-$i$]{\forall \alpha\alpha'. \fctx,O_{i,\alpha},O_{i,\alpha'},\tctx |- M_\alpha == M'_{\alpha'} : A}{\fctx,\tctx |- \digamma_i (M_\alpha)_\alpha == \digamma_i (M'_\alpha)_\alpha: A}
$$

The above rule is both the expected congruence rule for conversion and also a compatibility rule for typing that would be stated separately in a system with a pure typing judgement.

$$
    \inference[\textsc{Ask}-$i$]{\forall \alpha\alpha'. \fctx,O_{i,\alpha},O_{i,\alpha'},\tctx |- M_\alpha == M'_{\alpha'} : A}{\fctx,O_{i,\alpha},\tctx |- \digamma_i (M_{\alpha'})_{\alpha'} == M'_\alpha: A}
$$
The above rule is meant to hardwire the coherence $\varepsilon$ of the sheaf.

$$
    \inference[\textsc{Dig-Ev}]{\fctx,\tctx |- N == N' : A & \forall \alpha \alpha', \fctx, O_{i,\alpha},O_{i,\alpha},\tctx |- M_\alpha == M_{\alpha'} : \Pi x : A, B}{\fctx,\tctx |- (\digamma_i (M_\alpha)_\alpha) N == \digamma (M_\alpha N)_\alpha : B(N/x)}
$$
$$
    \inference[\textsc{Int-Rec-Dig}]{\fctx,\tctx |- A == A : \nat -> \square_\slvl & \fctx,\tctx |- M_0 == M'_0 : \nat & \fctx,\tctx |- M_S == M'_S : \Pi n : \nat, A n -> A (S n)\\ \forall \alpha \alpha', \fctx, O_{i,\alpha},O_{i,\alpha},\tctx |- M_\alpha == M_{\alpha'} : \nat}{\fctx,\tctx |- \nat_{\rec} AM_0M_S(\digamma_i (M_\alpha)_\alpha) == \digamma_i (\nat_{\rec}AM_0M_SM_\alpha)_\alpha : A \digamma_i (M_\alpha)_\alpha}
$$
$$
    \inference[\textsc{Emp-Rec-Dig}]{\fctx,\tctx |- A == A : \bot -> \square_\slvl & \forall \alpha \alpha', \fctx, O_{i,\alpha},O_{i,\alpha},\tctx |- M_\alpha == M_{\alpha'} : \bot}{\fctx,\tctx |- \bot_{\rec} A(\digamma_i (M_\alpha)_\alpha) == \digamma_i (\bot_{\rec}AM_\alpha)_\alpha : A \digamma_i (M_\alpha)_\alpha}
$$

This last few rules allows for pursuing computations on $\digamma$.

As such, terms of type $\nat$ should always be convertible to a term $\ovl{n'}$, where $n'$ is of type $\mnat'$
$$
\begin{array}{l}
    \Inductive\ \mnat' : \Type := \\
    \mid 0' : \mnat'\\
    \mid S' : \mnat' -> \mnat'\\
    \mid \ask' : \Pi (i : I),(A\ i -> \mnat') -> \mnat'\\
\end{array}
$$
With $\ovl{0'} := 0$, $\ovl{S'\ n'} := S\ \ovl{n'}$, and $\ovl{\ask\ i\ k} := \digamma_i (\ovl{k\ \alpha})_\alpha$. Furthermore, the same index $i$ should not occur twice in a branch.

This theory is unsatisfying with regards to the goal we set. For example, to instantiate it with \ref{MBshtt}, even adding the necessary generic function $\alpha$, and setting $I := \nat$, $A i = \bool$ and $O_{n,b} := n\mapsto_\alpha b$ so that \textsc{Dig}-$i$ may play the role of \textsc{Split}, we  have no way to provide the compatibility proof $n\mapsto \mtrue, n\mapsto \mfalse |- M_{\true} == M_{\false}$, which must be some form of ex-falso.

The \textsc{Ask} rule itself cannot be emulated, although this might be more an issue of level of generality.

\section{Logical relations}\label{LogRel}

A rather standard manner of studying the properties of a type theory is through logical relations. We roughly followed the recipe of Abel \cite{10.1145/3158111}, which, since it is meant for a system closer to MLTT, which would ease later scaling. In pratice, we used LogRel \rocq as a reference point \cite{DBLP:conf/cpp/AdjedjLMPP24}. We use \guillemotleft~logical relations~\guillemotright\ in a rather precise manner to designate this recipe. Roughly speaking, we establish a reduction relation and interpret terms by their reduction to a normal form.

\subsection{System T extension}

To get a hang of $\digamma$ and logical relations we started by studying a extension of system T with $\digamma$

Again the terms simply extend those of system T~:

$$ M,N ::= \dots \mid\digamma_i(M_\alpha)_\alpha$$

Rules from system T are then appropriately completed with a forcing context, and the same final rules are appended.
$$
    \inference[\textsc{Dig}-$i$]{\forall \alpha\alpha'. \fctx,O_{i,\alpha},O_{i,\alpha'},\tctx |- M_\alpha == M'_{\alpha'} : A}{\fctx,\tctx |- \digamma_i (M_\alpha)_\alpha == \digamma_i (M'_\alpha)_\alpha: A}
$$

$$
    \inference[\textsc{Ask}-$i$]{\forall \alpha\alpha'. \fctx,O_{i,\alpha},O_{i,\alpha'},\tctx |- M_\alpha == M'_{\alpha'} : A}{\fctx,O_{i,\alpha},\tctx |- \digamma_i (M_{\alpha'})_{\alpha'} == M'_\alpha: A}
$$
$$
    \inference[\textsc{Dig-Ev}]{\fctx,\tctx |- N == N' : A & \forall \alpha \alpha', \fctx, O_{i,\alpha},O_{i,\alpha},\tctx |- M_\alpha == M_{\alpha'} : A -> B}{\fctx,\tctx |- (\digamma_i (M_\alpha)_\alpha) N == \digamma (M_\alpha N)_\alpha : B}
$$
$$
    \inference[\textsc{Int-Rec-Dig}]{ \fctx,\tctx |- M_0 == M'_0 : \nat & \fctx,\tctx |- M_S == M'_S : \nat -> A -> A\\ \forall \alpha \alpha', \fctx, O_{i,\alpha},O_{i,\alpha},\tctx |- M_\alpha == M_{\alpha'} : \nat}{\fctx,\tctx |- \nat_{\rec} M_0M_S(\digamma_i (M_\alpha)_\alpha) == \digamma_i (\nat_{\rec}M_0M_SM_\alpha)_\alpha : A}
$$
$$
    \inference[\textsc{Emp-Rec-Dig}]{\forall \alpha \alpha', \fctx, O_{i,\alpha},O_{i,\alpha},\tctx |- M_\alpha == M_{\alpha'} : \bot}{\fctx,\tctx |- \bot_{\rec}(\digamma_i (M_\alpha)_\alpha) == \digamma_i (\bot_{\rec}M_\alpha)_\alpha : A }
$$

\subsection{Reducibility}

We then applied logical relations to our system T variant.

We define our reduction relation as follows~:

$$
    \inference{M\leadsto M'}{MN \leadsto M'N} \qquad
    \inference{}{(\lambda x. M)N \leadsto M(N/x)}
$$
$$
    \inference{M \leadsto M'}{\nat_{\rec}M_0M_S M\leadsto\nat_{\rec}M_0M_SM'}\qquad
    \inference{}{\nat_{\rec}M_0M_SO \leadsto M_0}\qquad
    \inference{}{\nat_{\rec} M_0M_S (S M) \leadsto M_SM(\nat_{\rec}M_0M_SM )}
$$
$$
    \inference{M \leadsto M'}{\bot_{\rec}M\leadsto\nat_{\rec}M'}
$$

And our neutrals as follows, through the predicate $\neu$~:

$$
    \inference{}{\neu x} \qquad
    \inference{\neu n}{\neu n M} \qquad
    \inference{\neu n}{\neu \nat_{\rec}M_0M_S n} \qquad
    \inference{\neu n}{\neu \bot_{\rec}n}
$$

We can then define a reducibility predicate $||-$ as follows, by induction on the type.
\begin{itemize}
    \item For type $A -> B$, $\fctx,\tctx ||- M == M' : A -> B$, if for all $\fctx',\tctx'$ such that $\fctx\subset\fctx'$, and $\tctx$ is a prefix of $\tctx'$, if $\fctx',\tctx' ||- N == N' : A$, then $\fctx', \tctx' ||- MN == M'N'$.
    \item For type $\nat$, we define inductively :
$$
    \inference{M \leadsto^\ast 0&M' \leadsto^\ast 0}{\fctx,\tctx ||- M == M' : \nat}\qquad
    \inference{M \leadsto^\ast SN&M' \leadsto^\ast SN' &\fctx,\tctx ||- N == N' : \nat}{\fctx,\tctx ||- M == M' : \nat}
$$
$$
    \inference{M \leadsto^\ast n&M' \leadsto^\ast n' &\neu n & \neu n'}{\fctx,\tctx ||- M == M' : \nat}
$$
$$
    \inference{M \leadsto^\ast \digamma_i (M_\alpha)_\alpha&M' \leadsto^\ast \digamma_i({M'_\alpha})_\alpha & \forall \alpha,\alpha' ||- M_\alpha == M'_{\alpha'} : \nat}{\fctx,\tctx ||- M == M' : \nat}
$$
$$
    \inference{M \leadsto^\ast \digamma_i(M_\alpha)_\alpha&M' \leadsto^\ast M'_\alpha & O_{i,\alpha}\in \fctx & \forall \alpha,\alpha', \fctx,\tctx ||- M_\alpha == M'_{\alpha'} : \nat}{\fctx,\tctx ||- M == M' : \nat}
$$
$$
    \inference{M \leadsto^\ast M_\alpha&M' \leadsto^\ast \digamma_i (M'_\alpha)_\alpha & O_{i,\alpha}\in \fctx & \forall \alpha,\alpha', \fctx,\tctx ||- M_\alpha == M'_{\alpha'} : \nat}{\fctx,\tctx ||- M == M' : \nat}
$$
    \item For type $\bot$, we use a similar definition as above excluding the case mentioning $0$ and the case mentioning $S$ 
\end{itemize}

We can then show the usual results, all proven in $\rocq$~:

\begin{lemma}[reflection]
    If $\neu n$ and $\neu n'$, then $\fctx,\tctx ||- n == n' : A$.
\end{lemma}
\begin{lemma}[reification]
    If $\fctx,\tctx ||- M == M' : A$, then $M$ and $M'$ normalise.
\end{lemma}

\begin{theorem}[soundness]
    If $\fctx,\tctx |- M == M' : A$, then if $\fctx \subset \fctx'$, $\fctx',\tctx'||-\sigma == \sigma' : \Gamma$, $\fctx',\tctx' ||- M\sigma == M'\sigma' : A$
\end{theorem}
Where substitution are encoded as lists of terms and reducibility of substitution is reducibility of each of these terms. Transitivity (\textsc{Trans}) made up the bulk of the proof.

We can then deduce that our theory normalises.

A canonicity result could easily follow as well, once hereditary reduction has been defined, with normal form of booleans some variant of dialogue trees instead of sheaves, since $\varepsilon$ has no corresponding reduction rule.
\section{Conclusion}

This constitutes a very incomplete work. I don't think attempting to prove normalisation of ShTT is the next step, same for any theories at the same level of generality. It might be more interesting to either look at continuity for a more general $\alpha$ than in Martin Baillon's work, or find a simple enough theory with non-empty intersections.

%\newpage
%
%\appendix
%\appendixname
%
%\section{Models}
%\subsection{Dialogue trees}
%
%\section{Dummy}

\printbibliography
\end{document}