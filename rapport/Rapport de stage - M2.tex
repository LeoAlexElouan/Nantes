\documentclass[11pt]{article}
\usepackage{graphicx} % Required for inserting images
\usepackage[a4paper, lmargin = 1cm, rmargin =1cm, tmargin = 1cm, bmargin = 2cm]{geometry}


\usepackage{tikz}
\usetikzlibrary{cd}
\usepackage{quiver}

\usepackage[sorting=none]{biblatex}
\addbibresource{reference.bib}


\usepackage{mathrsfs}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{stmaryrd }
\usepackage[T1]{fontenc}
\usepackage{euscript}



\usepackage{adjustbox}

\usepackage{color}


\usepackage{semantic}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{ndefinition}[theorem]{Not-a-Definition}

\DeclareMathOperator{\colim}{colim}
\DeclareMathOperator{\Prop}{\mathsf{Prop}}
\DeclareMathOperator{\SProp}{\mathsf{SProp}}
\DeclareMathOperator{\Type}{\mathsf{Type}}
\DeclareMathOperator{\ask}{\mathsf{ask}}
\DeclareMathOperator{\bind}{\mathsf{bind}}
\DeclareMathOperator{\Inductive}{\mathsf{Inductive}}
\DeclareMathOperator{\ret}{\mathsf{ret}}
\DeclareMathOperator{\rec}{rec}
\DeclareMathOperator{\ctx}{\mathsf{ctx}}
\DeclareMathOperator{\Typ}{\mathsf{Typ}}
\DeclareMathOperator{\trm}{\mathsf{Trm}}
\DeclareMathOperator{\true}{\mathsf{tt}}
\DeclareMathOperator{\false}{\mathsf{ff}}
\DeclareMathOperator{\neu}{Ne}


\newcommand{\ovarr}{\overrightarrow}
\newcommand{\ovl}{\overline}
\newcommand{\omlim}{A_0+\sum\limits_{i\geq 1}\ovl A_i}

\newcommand{\0}{\mathbf{0}}
\newcommand{\1}{\mathbf{1}}
\newcommand{\nat}{\mathbf{N}}
\newcommand{\bool}{\mathbf{B}}
\newcommand{\C}{\mathcal{C}}
\newcommand{\D}{\mathcal{D}}
\newcommand{\SBS}{\mathbf{SBS}}

\newcommand{\Gram}{\mathsf{G}}
\newcommand{\mono}{\rightarrowtail}
\newcommand{\omop}{\omega^{op}}
\newcommand{\omopch}{\Theta}
\newcommand{\omch}{\Omega}
\newcommand{\Dist}{\mathsf{Dist}}
\newcommand{\gd}{\dot {\mathbf{Fun}}}
\newcommand{\colomf}[1]{\varinjlim\circ\omch_{#1}^{(-)}}
\newcommand{\colom}[2]{\varinjlim(\omch_{#1}^{#2})}
\newcommand{\lcontext}{\Gamma}
\newcommand{\rcontext}{\Delta}
\newcommand{\lvar}{\gamma}
\newcommand{\rvar}{\delta}

\newcommand{\tctx}{\Gamma}
\newcommand{\tvar}{\gamma}
\newcommand{\diag}{\Delta}
\newcommand{\DThunk}{\mathsf{Dist}}

\newcommand{\Unit}{\mathsf{Unit}}
\newcommand{\Bool}{\mathsf{Bool}}
\newcommand{\Real}{\mathsf{Real}}
\newcommand{\Nat}{\mathsf{Nat}}
\newcommand{\List}{\textsf{List}}
\newcommand{\Stream}{\textsf{Stream}}

\newcommand{\Wf}{\textsf{well-formed}}
\newcommand{\slvl}{\mathbf{s}}
\newcommand{\llvl}{\mathbf{l}}
\newcommand{\fctx}{\mathcal{L}}


\mathlig{<-}{\leftarrow}
\mathlig{->}{\to}
\mathlig{|->}{\mapsto}
\mathlig{=>}{\Rightarrow}
\mathlig{|-}{\vdash}
\mathlig{||-}{\Vdash}
\mathlig{[|}{\llbracket}
\mathlig{|]}{\rrbracket}

\mathlig{==}{\equiv}

\reservestyle{\command}{\mathsf}
\command{inl,inr,wrap,roll,rec,corec,as,match,return,let,in,sample,on,do}


% Distributions in programming language
\newcommand{\Uniform}{\mathsf{uniform}}


\title{Internship report M2\\  Non-singleton Elimination\\}
\author{\textbf{Soudant L\'eo}, supervised by \textbf{Pierre-Marie P\'edrot}, Galinette team}
\date{2025}


\begin{document}


\begin{titlepage}
    
\maketitle

\end{titlepage}


\subsection*{General context}
We attempt to create type theories corresponding with the properties of the internal languages of sheaf topoï. Martin Baillon succeeded for some instance of the problem.
\subsection*{Research problem}
An element of a topological sheaf may be defined over an open whenever it is defined on a cover of that open, so long as they are compatible over the intersections. We hope to be able to do something similar in a type theory, where open set correspond to proof irrelevant propositions. This requires special attention to the compatibility condition : when a disjunction covers a proposition, it should be possible to eliminate from this disjunction to create a term in any type whenever compatible marginal terms are found.
\subsection*{Your contribution}
I have proved using \textsc{Rocq} that a system T with a part of the wanted features normalises. I also have a model in \textsc{Rocq} where types are interpreted as sheaves, even though some other variant probably exists.
\subsection*{Arguments supporting its validity}
The type theory devellopped by Martin Baillon, which I aim to generalise, proved continuity of all functional $(\nat -> \bool) -> \bool$. I hope to find similar results at term.
\subsection*{Summary and future works}
I will refine the type theory further as well as study other instances like the one Martin Baillon studied. I should also make a fork of the logrel \textsc{Rocq} project, and adapt it to my theory.
\newpage
\tableofcontents
\newpage


\section{Introduction}

\subsection{The outline}

In section 2 we explain what type theory is and detail the basic type theory we will study. Section 3 present the construction we would like to make appear in type theory, and why we think it is possible and useful. Section 4 present work done on models of type theory, though the important part is precisely the model of sheaf, since its theory is what we ar etrying to build syntactically. Section 5 exposes 2 sheaf theories, one which comes from previous work and is an important inspiration, and the other which is a prototype of a generalisation. The last section, section 6, uses the recipe of logical relation to make a proof of concept using a weaker theory, which normalises.

\section{Type theory}

Type theory is a manner of formalising mathematics with a very different design from say set theory, and quite a bit closer in structure to a purely logical system like natural deduction.


\subsection{MLTT}
We present a variant of MLTT, a very standard type theory

It is also the theory that we will seek to extend.

We consider two levels of universes $\slvl$ and $\llvl$ for small and large.

We add a type $\nat$ of natural numbers and an empty type $\bot$ as positive types, in stead of the heavy syntax of a general inductive type. They both implement large elimination, meaning their induction principle can be used to construct function outputting types, like $\lambda A n, A^n$, in presence of a binary product.

With terms :

$$ M,N ::= x | \lambda x. M | MN | 0 | S | \nat_{\rec} | \bot_{\rec} | \nat | \bot | \Pi x :A.B | \square_\slvl | \square_\llvl$$


Contexts :
$$ \tctx ::= \tctx, x : A | \cdot $$

And conversion rules :

$$
    \inference[\textsc{Wf-Empty}]{}{\cdot |- \Wf} \qquad
    \inference[\textsc{Wf-Ext}]{\tctx |- A == A & \tctx |- \Wf}{ \tctx, x : A |- \Wf}
$$
$$
    \inference[\textsc{Int-Typ}]{\tctx |- \Wf}{\tctx |- \nat == \nat : \square_\ell} \qquad
    \inference[\textsc{Emp-Typ}]{\tctx |- \Wf}{\tctx |- \bot == \bot : \square_\ell}
$$
$$
    \inference[\textsc{Fun-Typ}]{\tctx |- A == A' : \square_\ell & \tctx, x : A |- B == B' : \square_\ell}{\tctx |- \Pi x  : A, B == \Pi x: A', B' : \square_\ell} \qquad
    \inference[\textsc{Typ-Typ}]{\tctx |- \Wf}{\tctx |- \square_\slvl == \square_\slvl: \square_\llvl}
$$


$$
    \inference[\textsc{Fun-Intro}]{\tctx, x : A |- M == M' : B &\tctx |- A == A : \square_\ell}{\tctx |- \lambda x. M == \lambda x. M' : \Pi x : A, B} \quad
    \inference[\textsc{Fun-Elim}]{\tctx |- M == M' : \Pi x:A, B& \tctx |- N == N' : A}{\tctx |- MN == M'N' : B(N/x)}
$$

$$
    \inference[\textsc{Axiom}]{\tctx |- \Wf & x : A \in \tctx }{\tctx |- x == x : A} \qquad
    \inference[\textsc{Beta}]{\tctx, x : A |- M == M' : B & \tctx |- N == N' : A}{\tctx |- (\lambda x. M)N == M'(N'/x) : B(N/x)}
$$

$$
    \inference[\textsc{Int-Zero}]{\tctx |- \Wf}{\tctx |- 0 == 0 : \nat} \qquad
    \inference[\textsc{Int-Succ}]{\tctx |- \Wf}{\tctx |- S == S : \nat -> \nat}
$$

$$
    \inference[\textsc{Int-Rec}]{\tctx |- \Wf}{\tctx |- \nat_{\rec} == \nat_{\rec} : \Pi A : \nat \to \square_\ell, A 0 \to \left(\Pi n:\nat, A n \to A (S n)\right) \to \Pi n :\nat, A n}
$$


$$
    \inference[\textsc{Int-Rec-Zero}]{\tctx |- A == A : \nat -> \square_\ell & \tctx |- N_0 == N'_0 == A 0\\ \tctx |- N_S == N_S : \Pi n:\nat, A n -> A(S n)}{\tctx |- \nat_{\rec} A N_0N_S0 == N'_0 : A 0}
$$
$$
    \inference[\textsc{Int-Rec-Succ}]{\tctx |- A == A' : \nat -> \square_\ell & \tctx |- N_0 == N'_0 == A 0\\ \tctx |- N_S == N'_S : \Pi n:\nat, A n -> A(S n) & \tctx |- N == N' :\nat}{\tctx |- \nat_{\rec} A N_0N_S (S N) == N'_S N' (\nat_{\rec}A' N'_0 N'_S N') : A (S N)}
$$


$$
    \inference[\textsc{Emp-Rec}]{\tctx |- \Wf}{\tctx |- \bot_{\rec} == \bot_{\rec} : \Pi A : \bot \to \square_\ell,\Pi e :\bot, A e}
$$

$$
    \inference[\textsc{Sym}]{\tctx |- M == M' : A}{\tctx |- M' == M : A} \qquad
    \inference[\textsc{Trans}]
    {\tctx |- M == M' :A & \tctx |- M' == M'' : A}{\tctx |- M == M'' : A}
$$

$$
    \inference[\textsc{Conv}]
    {\tctx |- M == M' :A & \tctx |- A == A' : \square_\ell}{\tctx M ==M' : A'}
$$

But it is useful to consider the extension with a type of booleans $\bool$, with new terms :
 $ M,N ::= \dots | \bool|\bool_{\rec}|\true|\false$

 And conversion rules

$$
    \inference[\textsc{Bool-True}]{\tctx |- \Wf}{\tctx |- \true == \true : \bool} \qquad
    \inference[\textsc{Bool-False}]{\tctx |- \Wf}{\tctx |- \false == \false : \bool}
$$

$$
    \inference[\textsc{Bool-Rec}]{\tctx |- \Wf}{\tctx |- \bool_{\rec} == \bool_{\rec} : \Pi A : \bool \to \square_\slvl, A \true \to A\false \to \Pi b :\bool, A b}
$$


$$
    \inference[\textsc{Bool-Rec-True}]{\tctx |- A == A : \bool -> \square_\slvl \\ \tctx |- M_{\true} == M'_{\true} == A {\true} & \tctx |- M_{\false} == M_{\false} : A \false}{\tctx |- \bool_{\rec} A M_{\true} M_{\false} \true == M'_{\true} : A \true}
$$
$$
    \inference[\textsc{Bool-Rec-False}]{\tctx |- A == A : \bool -> \square_\slvl \\ \tctx |- M_{\true} == M_{\true} == A \true & \tctx |- M_{\false} == M'_{\false} : A \false}{\tctx |- \bool_{\rec} A M_{\true} M_{\false} \false == M'_{\false} : A \false}
$$

%\subsection{Elimination}

%It is worth commenting further on elimination. Elimination is the process by which a constructor(respectively $\lambda.$ or $S$) are placed below a eliminator (resp. concatenation or $\nat_{\rec}$) so they combine and disappear (resp. rule \textsc{Beta} or \textsc{Int-Rec-Succ})


\subsection{System T}

To identify and solve problems in a simpler envirronement, we studied a modified System T before, based on the following variant.

With types :

$$ A ::= A -> A | \nat | \bot $$

Terms :

$$ M,N ::= x | \lambda x. M | MN | 0 | S | \nat_{\rec} | \bot_{\rec} $$


Contexts :
$$ \tctx ::= \tctx, x : A | \cdot $$

And conversion rules :


$$
    \inference[\textsc{Fun-Intro}]{\tctx, x : A |- M == M' : B }{\tctx |- \lambda x. M == \lambda x. M' : A -> B} \qquad
    \inference[\textsc{Fun-Elim}]{\tctx |- M == M' : A -> B& \tctx |- N == N' : A}{\tctx |- MN == M'N' : B}
$$

$$
    \inference[\textsc{Axiom}]{x : A \in \tctx }{\tctx |- x == x : A} \qquad
    \inference[\textsc{Beta}]{\tctx, x : A |- M == M' : B & \tctx |- N == N' : A}{\tctx |- (\lambda x. M)N == M' : B}
$$

$$
    \inference[\textsc{Int-Zero}]{\tctx |- \Wf}{\tctx |- 0 == 0 : \nat} \qquad
    \inference[\textsc{Int-Succ}]{\tctx |- \Wf}{\tctx |- S == S : \nat -> \nat}
$$

$$
    \inference[\textsc{Int-Rec}]{\tctx |- \Wf}{\tctx |- \nat_{\rec} == \nat_{\rec} : A \to \left(\nat -> A -> A \right) -> \nat -> A}
$$


$$
    \inference[\textsc{Int-Rec-Zero}]{\tctx |- N_0 == N'_0 == A\\ \tctx |- N_S == N_S : \nat -> A  -> A}{\tctx |- \nat_{\rec} N_0N_S0 == N'_0 : A}
$$
$$
    \inference[\textsc{Int-Rec-Succ}]{\tctx |- N_0 == N'_0 == A\\ \tctx |- N_S == N'_S : \nat -> A  -> A & \tctx |- N == N' :\nat}{\tctx |- \nat_{\rec} N_0N_S (S N) == N'_S N' (\nat_{\rec}N'_0 N'_S N') : A}
$$


$$
    \inference[\textsc{Emp-Rec}]{}{\tctx |- \bot_{\rec} == \bot_{\rec} : \bot -> A}
$$

$$
    \inference[\textsc{Sym}]{\tctx |- M == M' : A}{\tctx |- M' == M : A} \qquad
    \inference[\textsc{Trans}]
    {\tctx |- M == M' :A & \tctx |- M' == M'' : A}{\tctx |- M == M'' : A}
$$

\section{Sheaves}

\subsection{Sheaves on topological spaces}

While the notion of sheaves on topological space is the most distant from my own, I find that they offer a clearer insight on what sheaves are going to be used than sheaves on a grothendieck topology, and as such present the first and not the second in detail. Treating proof irrelevant proposition as subset of a space is a notion I like to keep in mind.

We fix a topological space $X$, in this case presheaves on that space are presheaves on the category underlying its poset of open subsets. More precisely :

\begin{definition}[Presheaf on a topology]
    A \emph{presheaf} $P$ is given by
    \begin{itemize}
        \item For every open $U \in \mathcal{O}(X)$, a set $P(U)$ of \emph{sections}
        \item For every open $U$, section $s\in P(U)$, and open subset $V\subseteq U$, a \emph{restriction} $s|_V\in P(V)$
        \item If $s\in P(U)$, $s|_U = s$
        \item If $s\in P(U)$, $W\subseteq V \subseteq U$, $(s|_V)|_W = s|_W$
    \end{itemize}
\end{definition}
The $\lambda (s\in P(U)), s|_V : P(U) -> P(V)$ function gives the $P(f)$ necessary to construct the functor $P : \mathcal{O}(X)^{op} -> \mathbf{Set}$ justifying the use of the same term presheaf here and in the categorical context.

While in general presheaves are unrelated to sheaves, we can introduce what sheaves look like in the topos (see definition \ref{topos}) of presheaves.

\begin{definition}[Sheaf on a topology]
    A \emph{sheaf} $\mathcal{F}$ is a presheaf such that given any open  $U$ and family of open $(U_i)_i$ such that $U = \bigcup_i U_i$, there is a bijection between :
    \begin{itemize}
        \item Sections $s$ of $U$
        \item \emph{Compatible} families $(s_i\in \mathcal{F}(U_i))_i$ of sections where $s_i|_{U_i\cap U_j} = s_j|_{U_i\cap U_j}$
    \end{itemize}
    where the forward direction is given by $s \mapsto (s|_{U_i})_i$.
\end{definition}

Since the definitions only access the open subsets and not the points of the space, they can be extended to \emph{locales}, that is, posets with finite meets and arbitrary joins satisfying the infinite distributive law. As far as we are concerned, this means $\vee,\wedge$ and $\leq$ will be used instead $\cup,\cap$ and $\subseteq$. I will stick with calling their elements opens, however.

\subsection{Kripke and Beth semantics}

Kripke models are models of intuitionistic logic, and come from interpreting the sorts of the language as presheaves.

To construct a Kripke model, we consider a locale (or in general, a small category). We consider a language and associate a downward closed set of opens to each of its proposititional variables.

We can then define $U ||- \phi$, meaning $U$ forces $\phi$, by induction on the structure of $\phi$.
\begin{itemize}
    \item $U ||- \phi \wedge \psi$ iff for all $V\leq U$, $V ||- \phi$ and $V ||- \psi$
    \item $U ||- \phi => \psi$ iff for all $V \leq U$, if $V ||- \phi$ then $V ||- \psi $
    \item $U ||- \forall x : P, \phi$ iff for all $V \leq U$ and $s\in P(V)$, $V ||- \phi(s/x) $
\end{itemize}
And all other case are similar. We can then prove that for all $\phi$, $U||-\phi$ iff for all $V \leq U$, $V ||- \phi$, making all cases but $ => $ and $\forall$ degenerate. For example, $U ||- \phi \wedge \psi$ iff for all $V \leq U$, $ V||- \phi$ and $V ||- \psi$ iff $U||- \phi$ and $V||- \psi$. This recovers the usual definition.

We note that by using the poset of contexts, Kripke model done with small categories is (only classicaly) complete for intuitionistic logic.

Sheaves also yield a more general kind of model, Beth models, where sorts are interpreted as sheaves.

$U ||- \phi$ is now defined as follows :
\begin{itemize}
    \item $U ||- \phi \wedge \psi$ iff for all $V \leq U$ there exists $(V_i)_i$ with $V = \bigvee_i V_i$, such that for all $i$, $V_i ||- \phi$ and $V_i ||- \psi $.
    \item $U ||- \phi \vee \psi $ iff for all $V \leq U$ there exists $(V_i)_i$ with $V = \bigvee_i V_i$, such that for all $i$, $V_i ||- \phi$ or $U_i ||- \psi $.
    \item $U ||- \exists x : \mathcal{F}, \phi $ iff for all $V\leq U$, there exists $(V_i)_i$ with $V = \bigvee_i V_i$, such that for all $i$, there exists $s_i\in \mathcal{F}(V_i)$, $V_i ||- \phi(s_i/x)$.
    \item $U ||- \phi => \psi $ iff for all $V \leq U$ there exists $(V_i)_i$ with $V = \bigvee_i V_i$, such that for all $i$, if $V_i ||- \phi$ then $U_i ||- \psi $.
    \item $U ||- \forall x : \mathcal{F}, \phi $ iff for all $V\leq U$, there exists $(V_i)_i$ with $V = \bigvee_i V_i$, such that for all $i$ and $s_i\in \mathcal{F}(V_i)$, $V_i ||- \phi(s_i/x)$.
\end{itemize}
Now it can also be proved that $U ||- \phi$ iff there exists $(V_i)_i$ with $V = \bigvee_i V_i$, for all $i$ $V_i||- \phi$, and the above degenerates into :
\begin{itemize}
    \item $U ||- \phi \wedge \psi$ iff $U ||- \phi$ and $U ||- \psi $.
    \item $U ||- \phi \vee \psi $ iff there exists $(U_i)_i$ with $U = \bigvee_i U_i$, such that for all $i$, $U_i ||- \phi$ or $U_i ||- \psi $.
    \item $U ||- \exists x : \mathcal{F}, \phi $ iff there exists $(U_i)_i$ with $U = \bigvee_i U_i$, such that for all $i$, there exists $s_i\in \mathcal{F}(U_i)$, $U_i ||- \phi(s_i/x)$.
    \item $U ||- \phi => \psi $ iff for all $V \leq U$, if $V ||- \phi$ then $V ||- \psi $.
    \item $U ||- \forall x : \mathcal{F}, \phi $ iff for all $V\leq U$ and $s\in \mathcal{F}(V)$, $V ||- \phi(s/x)$.
\end{itemize}

They are other variant of Beth semantics, relying on different notion of \emph{cover} in small categories.

\subsection{Topoï and sheaves in topoï}


Proofs, results and details for this section can often be found in \emph{Sheaves in geometry and logic: A first introduction to topos theory} by Saunders Maclane and Ieke Moerdijk \cite{maclane2012sheaves}.

\begin{definition}[Subobject]
    In a category, a \emph{subobject} of $X$ is an equivalence class of monomorphism $m : A \mono X$, where the equivalence comes from the preorder where $ m : A \mono X $ is smaller than $ m' : A' \mono X$ when there is a map $f : A -> A'$ with $ m' \circ f = m$.
\end{definition}

We deduce a presheaf $\mathbf{Sub}$ where $\mathbf{Sub}(X)$ is the the set of subobjects of $X$, and $\mathbf{Sub}(f) : \mathbf{Sub}(Y) -> \mathbf{Sub}(X)$ sends $m : A -> Y$ to its pullback by $f : X -> Y $. 

\begin{definition}[Topos]\label{topos}
    A \emph{topos} is a cartesian closed category with all finite limits and a suboject \emph{classifier} $\Omega$ and an isomorphism $\mathbf{Sub}(X)\cong \mathbf{Hom}(X, \Omega)$ natural in $X$.
\end{definition}

We note that topoï also have finite colimits.

Topoï form a class of models of type theory. However, the properties verified by their theories, are either too strong, like proposititional extensionality and the axiom of unique choice, or too weak {\color{red} TO COMPLETE}.

To give a few examples of topoï, $\mathbf{Set}$ is a topos, and given a topos $\mathcal E$, $\mathcal{E}/X$, the category of maps with codomain $X$ and commuting triangles, as well as $\mathcal{E}^{\mathbf{C}^{op}}$, the category of contravariant functors from a small category $\mathbf{C}$ and natural transformation, are all topoï. In particular categories of presheaves are topoï, and their internal language are given by Kripke models. The categories of sheaves over topological spaces also form topoï, and their internal language are given by Beth models.

The subobject classifier $\Omega$ is equipped with an internal meet-semilattice structure inherited from the meet-semilattice structure on each $\mathbf{Sub}(X)$, which is natural in $X$.

\begin{definition}[Lawvere-Tierney topology]
    A \emph{Lawvere-Tierney topology} is a left exact idempotent monad $j$ on the internal meet-semilattice on $\Omega$.
\begin{itemize}
    \item $ id_\Omega \leq j $,
    \item $ j\circ j \leq  j$
    \item $ j \circ \wedge = \wedge \circ j\times j$
\end{itemize}
\end{definition}

From a topology $j$ we extract a closure operator $J_X$ of $\mathbf{Sub}(X)$ for any $X$.
\begin{definition}[Dense subobject]
    A suboject $U$ of $X$ is dense if $J_XU  = X$
\end{definition}

A topology can be lifted to a left exact idempotent monad on the entirety of the topos, the sheafification monad.

\begin{definition}[$j$-Sheaf in topos]
    An object $F$ is a $j$-\emph{sheaf} in a topos if for any dense subobject $U$ of any object $X$, the morphism $\mathbf{Hom}(X, F) -> \mathbf{Hom}(U, F)$ obtained by precomposition is an isomorphism.
\end{definition}

A $j$-Sheaf is up to isomorphism the result of sheafifying an object.

$j$-Sheaves form a topos.

In the topos of presheaf over $X$, elements of $\Omega$ are downward closed sets of open. The $j$ operator send such set to the set of sub-open of their union. A subobject $A$ of $P$ is then dense if for every open $U$ and every section $s$ of $P(U)$, there is a family of opens and sections $s_i\in U_i$ which can be glued back into $s$, \emph{i.e.} $U = \bigvee U_i$ and $s_i = s|_{U_i}$. Although, to recover the earlier sheaf definition, one can simply look at presheaves $P$ where $P(U)$ has at most one element, since morphisms out of these presheaves directly yield compatible families.

\subsection{Geometric formulas}
In the litterature around sheaves and forcing, we find the following definitions.
\begin{ndefinition}
A \emph{geometric formula} is a formula built from $\exists, \wedge,\bigvee$, and atomic formulas.
\end{ndefinition}
\begin{ndefinition}
A \emph{geometric implication} is a formula of shape $\forall \overrightarrow{x}, \phi(\overrightarrow{x}) -> \psi(\overrightarrow{x})$, where $\phi$ and $\psi$ are geometric.
\end{ndefinition}
\begin{ndefinition}
    A \emph{geometric theory} is a set geometric implication.
\end{ndefinition}
We rather use the following definition

\begin{definition}
    A \emph{geometric formula} is a formula of the form $$\bigwedge_{i\in I}\left(\forall \overrightarrow{x}, \bigwedge_{j \in J_i} O_{i,j}(\overrightarrow{x}) -> \bigvee_{k\in K_i}\exists \overrightarrow{y},\bigwedge_{l\in L_{i,k}} Q_{i,k,l}(\overrightarrow{x},\overrightarrow{y})\right)$$
    Where $O_{i,j}$ and $Q_{i,k,l}$ are atomic formulas, and both every $J_i$ and every $L_{i,k}$ are finite.
\end{definition}

Every \guillemetleft geometric theory \guillemetright can be written as a single geometric formula.

We'd like to note that they define covers and be read as saying that some intersection of atoms can be covered by a family of intersection of atoms, and that they may be integrated in a deduction system as : 
$$
    \inference[\textsc{Geo}-$i$]{Q_{i,1,1}(\overrightarrow{x},\overrightarrow{t_1})\dots Q_{i,1,m_{i,1}}(\overrightarrow{x},\overrightarrow{t_1})|-\mathcal{J}\ \cdots\ Q_{i,p_i,1}(\overrightarrow{x},\overrightarrow{t_{p_i}})\dots Q_{i,p_i,m_{i,p_i}}(\overrightarrow{x},\overrightarrow{t_{p_i}})|-\mathcal{J}}{O_{i,1}(\overrightarrow{x}),\dots O_{i,n_i}(\overrightarrow{x})|-\mathcal{J}}
$$


\subsection{Sheaves in type theory}

Consider a type theory with a notion of proof irrelevant propositions $\Prop$, \emph{e.g.} book-HoTT with mere propositions, or \textsc{Rocq} with $\SProp$.

In this case, a Lawvere-Tierney topology may be similarily defined, as a monad:
\begin{itemize}
    \item $\mathsf{J} : \Prop -> \Prop$
    \item $\eta : \Pi (P:\Prop).P -> \mathsf{J}\ P$
    \item $\bind : \forall (P Q: \Prop). \mathsf{J}\ P -> (P -> \mathsf{J}\ Q) -> \mathsf{J}\ Q$
\end{itemize}

Then a sheaf is just a type $T$ with 
\begin{itemize}
    \item A map $\ask_T : \Pi (P:\Prop).\ \mathsf{J}\ P -> (P -> T) -> T$
    \item A coherence $\varepsilon_T : \Pi (P:\Prop)\ (j : \mathsf{J}\ P)\ (x:T).\ \ask_T\ P\ j\ (\lambda p:P.x) = x$
\end{itemize}

Now, the sheafified of a type doesn't exists in general, if the theory admits quotient inductive types, it can then be defined as follow :

$$
\begin{array}{l}
    \Inductive\ \mathcal{S}_{\mathsf{J}}\ T : \Type := \\
    | \ret : T -> \mathcal{S}_{\mathsf{J}}\ T\\
    | \ask : \Pi (P:\Prop), \mathsf{J}\ P -> (P -> \mathcal{S}_{\mathsf{J}}\ T) -> \mathcal{S}_{\mathsf{J}}\ T\\
    |\ \varepsilon : \Pi (P:\Prop)\ (j : \mathsf J\ P)\ (x : \mathcal{S}_{\mathsf{J}}\ T). \ask\ P\ j\ (\lambda p:P. x) = x
\end{array}
$$

We note that by taking $I := \Sigma (P:\Prop). \mathsf{J}\ P$ and $O\ (P,j) : P$, a sheaf is then defined as
\begin{definition}\label{IOshf}
    A \emph{sheaf} or \emph{$(I,O)$-sheaf}, is given by
\begin{itemize}
    \item A type $T$
    \item A map $\ask_T : \Pi (i:I), (O\ i -> T) -> T$
    \item A coherence map $\varepsilon_T : \Pi(i:I)\ (x:T), \ask_T\ i\ (\lambda o:O\  i.x) = x$
\end{itemize}

\end{definition}

$(I,O)$-Sheafification can be defined similarily. This definition is marginally simpler, and make sheaves appear as quotient dialogue trees, hence why we will henceforth consider \emph{$(I,O)$-sheaves} instead of \emph{$\mathsf{J}$-sheaves}.

It is also possible to see geometric formulas as being of the form $\Pi i : I, O i$, and as such be used as the basis for sheaves.

\section{Models}

\subsection{Categories with family}

A common manner to construct models of type theory is through categories with families.

They are constituted of :
\begin{itemize}
    \item A category of context and substitution
    \item For every context a type of inner types, and for every context and inner type in that context, a type of terms, both accompanied by the action of the substitution upon those, and the corresponding rules.
    \item A way to append a type to a context, substitution weakening, lifting and extension.
\end{itemize}
They may be complemented by :
\begin{itemize}
    \item Dependent function inner types, with their constructor, eliminator, and their substitution laws.
    \item A universe inner type, and its element function and their substitution laws.
    \item Some positive types, like a boolean type, its eliminator and constructors, and their substitution laws.
    \item Dependent pair inner types, eliminators, constructors, and laws.
\end{itemize}

A significant part of my internship was dedicated to contructing models of type theory in \textsc{Rocq}, using categories with families.

The most notable being :
\begin{enumerate}
    \item A model using dialogue trees.
    \item An exceptional model.
    \item A model using presheaves.
    \item A model using $(I,O)$-sheaves, which requires univalence, and quotient inductive types to model positive types.
\end{enumerate}

None of them completely implement all the feature listed above, but only the model using presheaves as no dependent function type.

\textsc{Rocq} served as both the meta-theory and the target.

\subsection{Dialogue trees}

An $(I,O)$-dialogue tree, is a type $A$ together with a map $\Pi i : I, (O\ i-> A) -> A$. More important, maybe, are how free dialogue tree are defined : 

$$
\begin{array}{l}
    \Inductive\ \mathcal{D}_{I,O}\ T : \Type := \\
    | \ret : T -> \mathcal{D}_{I,O}\ T\\
    | \ask : \Pi (i : I),(O\ i -> \mathcal{D}_{I,O}\ T) -> \mathcal{D}_{I,O}\ T\\
\end{array}
$$

They encode a fairly large family of monads. They are quite similar to sheaves, however, unlike sheaves, a model interpreting types as dialogue trees do not require no univalence nor HITs, but cannot implement booleans (or in general, inductive types) as usual.

Instead, they implement them in the way of Baclofen TT, meaning $\textsf{if } b \textsf{ then } (p_t : P \true) \textsf{ else } (p_f : P \false)$ is of type $\textsf{if } b \textsf{ then } P\true \textsf{ else } P\false$ rather than $P b$ (except if $P$ is constant).

This models highlights how sheaves do not need to weaken the theory down to Baclofen TT to add effects

\subsection{Exceptional}

The exceptional model (for exception type $E$) interprets a type as a pair of a type and a map $E -> A$. It is inconsistent, however, together with parametricity, a consistent model can be recovered.

This models highlights the importance of computations, since an inconsitent type theory can still be used to state a few thing as long as it computes properly.

\subsection{Presheaves}

The most time consuming model, where neither universes nor dependant function types could be implemented. The main issue is the straightforward implementation is not strict, meaning equalities have to be proven, and transport along them must be handled.

This model highlights why studying sheaves separately from presheaves is interesting.

\subsection{Sheaves}

The most important one is of course the model using sheaves.

The model requires univalence and used rewrite rules to simulate HIT, which are absent in \textsc{Rocq} 9.0.0.

Types were interpreted as sheaves as described in definition \ref{IOshf}. Product types are relatively easy as an aribtray product of sheaves is still a sheaf. Positives types, in my case boolean, where contructed as the QIT with the same constructor as the original (true and false), together with $\ask$ and $\varepsilon$. The resulting type is equivalent to the sheafification of booleans but does not compute exactly the same.

One of the interest of type theory is that it yield meaningful computations from proof, so we were careful about that.



\section{ShTT}
\subsection{Martin Baillon's ShTT}\label{MBshtt}
My work was meant to generalise the work of my supervisor past PhD student, Martin Baillon. He worked on a roughly similar MLTT extended with boolean and a generic function $\alpha$, based on the geometric formula 

$$ \left(\bigwedge_{n\in\nat} \top -> \alpha n = \true \vee \alpha n = \false\right) \wedge \left(\bigwedge_{n\in \nat} \alpha n = \true \wedge \alpha n = \false -> \bot \right)$$

The term then extends those of MLTT with
$$ M, N ::= \dots |\alpha$$

With \emph{forcing contexts}, with $n$ and $b$ an integer and boolean respectively
$$ \fctx ::= \fctx, n \mapsto b | \cdot$$
We write $n\mapsto_\fctx b$ when $n\mapsto b$ appears in $\fctx$, and $n\not\mapsto_\fctx$ when neither $n\mapsto \true$ nor $n\mapsto \false$ do.

And conversion rules :
$$
    \inference[name]{\fctx,\tctx |- \mathcal{J}_0 & \cdots & \fctx,\tctx |- \mathcal{J}_n}{\fctx,\tctx |- \mathcal{J}}
$$
whenever the following is a rule of MLTT (with booleans)
$$
    \inference[name]{\tctx |- \mathcal{J}_0 & \cdots & \tctx |- \mathcal{J}_n}{\tctx |- \mathcal{J}}
$$

Exception made of \textsc{Wf-Empty}, which becomes
$$
    \inference[\textsc{Wf-Empty}]{}{\cdot,\cdot |- \Wf}
$$

The new conversion rules are :
$$
    \inference[\textsc{Wf-Ext-Forc}]{\fctx,\tctx |- \Wf & n\not\mapsto_\fctx}{\fctx, n\mapsto b, \tctx |- \Wf}
$$
$$
    \inference[\textsc{Gen}]{\fctx,\tctx|- \Wf}{\fctx,\tctx |- \alpha == \alpha : \nat -> \bool}
    \qquad
    \inference[\textsc{Ask}]{\fctx,\tctx|- \Wf &n\mapsto_\fctx b}{\fctx, \tctx |- \alpha \ovl n == \ovl b}
$$
$$
    \inference[\textsc{Split}]{\fctx,n\mapsto \true,\tctx |-M == M' :A & \fctx, n\mapsto\false, \tctx |- M == M' : A & n\not\mapsto_\fctx}{\fctx,\tctx |- M == M' : A}
$$

Amongst other thing, this theory can be used to show that from any term $\cdot |- M == M : (\nat -> \bool) -> \nat$ of MLTT, a term $\cdot |- \{M\} == \{M\} : \mathsf{continuous} M$ of MLTT proving its continuity can be constructed.

\subsection{ShTT}

Being sheaves, the model of every type contained a map $\ask$, we sought to create our type theory of sheaves by adding this map to the syntax under the name $\digamma$

We imagine we have a set $\Omega$ of \emph{atoms}.
We first set a set $I$ with decidable equality, and a (morally finite) set $A i$ for each $i \in I$ standing for arity, and finally a family $((O_{i,\alpha})_{\alpha \in A i})_{i\in I}$ of elements of $\Omega$.

This roughly correspond to the geometric formula : 
$\bigwedge_{i\in I} \top -> \bigvee_{\alpha \in A\ i}O_{i,\alpha}$

The term extend those of MLTT as follows :

$$ M, N ::= \dots | \digamma_i (M_\alpha)_{\alpha\in A i}$$

When instanciating with finite $A i$, it would rather be  $\digamma_i M_1 \cdots M_n$.

The forcing contexts $\fctx$ are now subset of $\Omega$, and never cause ill-formation.

The conversion rules also copy those from MLTT by adding a forcing context as in \ref{MBshtt}, without the \textsc{WF-Empty} exception.

The new conversion rules are as follows :

$$
    \inference[\textsc{Dig}-$i$]{\forall \alpha\alpha'. \fctx,O_{i,\alpha},O_{i,\alpha'},\tctx |- M_\alpha == M'_{\alpha'} : A}{\fctx,\tctx |- \digamma_i (M_\alpha)_\alpha == \digamma_i (M'_\alpha)_\alpha: A}
$$

This rule is both the expected congruence rule for conversion and also a compatibility rule for typing that would be stated separately in a system with a purre typing judgement.

$$
    \inference[\textsc{Ask}-$i$]{\forall \alpha\alpha'. \fctx,O_{i,\alpha},O_{i,\alpha'},\tctx |- M_\alpha == M'_{\alpha'} : A}{\fctx,O_{i,\alpha},\tctx |- \digamma_i (M_{\alpha'})_{\alpha'} == M'_\alpha: A}
$$
$$
    \inference[\textsc{Dig-Ev}]{\fctx,\tctx |- N == N' : A & \forall \alpha \alpha', \fctx, O_{i,\alpha},O_{i,\alpha},\tctx |- M_\alpha == M_{\alpha'} : \Pi x : A, B}{\fctx,\tctx |- (\digamma_i (M_\alpha)_\alpha) N == \digamma (M_\alpha N)_\alpha : B(N/x)}
$$
$$
    \inference[\textsc{Int-Rec-Dig}]{\fctx,\tctx |- A == A : \nat -> \square_\slvl & \fctx,\tctx |- M_0 == M'_0 : \nat & \fctx,\tctx |- M_S == M'_S : \Pi n : \nat, A n -> A (S n)\\ \forall \alpha \alpha', \fctx, O_{i,\alpha},O_{i,\alpha},\tctx |- M_\alpha == M_{\alpha'} : \nat}{\fctx,\tctx |- \nat_{\rec} AM_0M_S(\digamma_i (M_\alpha)_\alpha) == \digamma_i (\nat_{\rec}AM_0M_SM_\alpha)_\alpha : A \digamma_i (M_\alpha)_\alpha}
$$
$$
    \inference[\textsc{Emp-Rec-Dig}]{\fctx,\tctx |- A == A : \bot -> \square_\slvl & \forall \alpha \alpha', \fctx, O_{i,\alpha},O_{i,\alpha},\tctx |- M_\alpha == M_{\alpha'} : \bot}{\fctx,\tctx |- \bot_{\rec} A(\digamma_i (M_\alpha)_\alpha) == \digamma_i (\bot_{\rec}AM_\alpha)_\alpha : A \digamma_i (M_\alpha)_\alpha}
$$

This theory is still incomplete. For example, to instantiate it with \ref{MBshtt}, even adding the necessary generic function $\alpha$, and setting $I := \nat$, $A i = \bool$ and $O_{n,b} := n\mapsto b$ so that \textsc{Dig}-$i$ may play the role of \textsc{Split}, we  have no way to provide the compatibility proof $n\mapsto \true, n\mapsto \false |- M_{\true} == M_{\false}$, which must be some form of ex-falso. \textsc{Ask}-$i$ cannot be used in stead of \textsc{Ask} either.

\section{Logical relations}

\subsection{System T extension}

To get a hang of $\digamma$ and logical relations I started by studying a extension of system with $\digamma$

Again the terms simply extend those of system T :

$$ M,N ::= \dots | \digamma_i(M_\alpha)_\alpha$$

And rules from system are appropriately completed with a forcing context.
$$
    \inference[\textsc{Dig}-$i$]{\forall \alpha\alpha'. \fctx,O_{i,\alpha},O_{i,\alpha'},\tctx |- M_\alpha == M'_{\alpha'} : A}{\fctx,\tctx |- \digamma_i (M_\alpha)_\alpha == \digamma_i (M'_\alpha)_\alpha: A}
$$

$$
    \inference[\textsc{Ask}-$i$]{\forall \alpha\alpha'. \fctx,O_{i,\alpha},O_{i,\alpha'},\tctx |- M_\alpha == M'_{\alpha'} : A}{\fctx,O_{i,\alpha},\tctx |- \digamma_i (M_{\alpha'})_{\alpha'} == M'_\alpha: A}
$$
$$
    \inference[\textsc{Dig-Ev}]{\fctx,\tctx |- N == N' : A & \forall \alpha \alpha', \fctx, O_{i,\alpha},O_{i,\alpha},\tctx |- M_\alpha == M_{\alpha'} : A -> B}{\fctx,\tctx |- (\digamma_i (M_\alpha)_\alpha) N == \digamma (M_\alpha N)_\alpha : B}
$$
$$
    \inference[\textsc{Int-Rec-Dig}]{ \fctx,\tctx |- M_0 == M'_0 : \nat & \fctx,\tctx |- M_S == M'_S : \nat -> A -> A\\ \forall \alpha \alpha', \fctx, O_{i,\alpha},O_{i,\alpha},\tctx |- M_\alpha == M_{\alpha'} : \nat}{\fctx,\tctx |- \nat_{\rec} M_0M_S(\digamma_i (M_\alpha)_\alpha) == \digamma_i (\nat_{\rec}M_0M_SM_\alpha)_\alpha : A}
$$
$$
    \inference[\textsc{Emp-Rec-Dig}]{\forall \alpha \alpha', \fctx, O_{i,\alpha},O_{i,\alpha},\tctx |- M_\alpha == M_{\alpha'} : \bot}{\fctx,\tctx |- \bot_{\rec}(\digamma_i (M_\alpha)_\alpha) == \digamma_i (\bot_{\rec}M_\alpha)_\alpha : A }
$$

\subsection{Reducibility}

We define our reduction relation as follows :

$$
    \inference{M\leadsto M'}{MN \leadsto M'N} \qquad
    \inference{}{(\lambda x. M)N \leadsto M(N/x)}
$$
$$
    \inference{M \leadsto M'}{\nat_{\rec}M_0M_S M\leadsto\nat_{\rec}M_0M_SM'}\qquad
    \inference{}{\nat_{\rec}M_0M_SO \leadsto M_0}\qquad
    \inference{}{\nat_{\rec} M_0M_S (S M) \leadsto M_SM(\nat_{\rec}M_0M_SM )}
$$
$$
    \inference{M \leadsto M'}{\bot_{\rec}M\leadsto\nat_{\rec}M'}
$$

And our neutrals as follows, through the predicate $\neu$ :

$$
    \inference{}{\neu x} \qquad
    \inference{\neu n}{\neu n M} \qquad
    \inference{\neu n}{\neu \nat_{\rec}M_0M_S n} \qquad
    \inference{\neu n}{\neu \bot_{\rec}n}
$$

We can then define a reducibility predicate $||-$ as follows, by induction on the type.
\begin{itemize}
    \item For type $A -> B$, $\fctx,\tctx ||- M == M' : A -> B$, if for all $\fctx',\tctx'$ such that $\fctx\subset\fctx'$, and $\tctx$ is a prefix of $\tctx'$, if $\fctx',\tctx' ||- N == N' : A$, then $\fctx', \tctx' ||- MN == M'N'$.
    \item For type $\nat$, we define inductively :
$$
    \inference{M \leadsto 0&M' \leadsto 0}{\fctx,\tctx ||- M == M' : \nat}\qquad
    \inference{M \leadsto SN&M' \leadsto SN' &\fctx,\tctx ||- N == N' : \nat}{\fctx,\tctx ||- M == M' : \nat}
$$
$$
    \inference{M \leadsto n&M' \leadsto n' &\neu n & \neu n'}{\fctx,\tctx ||- M == M' : \nat}
$$
$$
    \inference{M \leadsto \digamma_i (M_\alpha)_\alpha&M' \leadsto \digamma_i({M'_\alpha})_\alpha & \forall \alpha,\alpha' ||- M_\alpha == M'_{\alpha'} : \nat}{\fctx,\tctx ||- M == M' : \nat}
$$
$$
    \inference{M \leadsto \digamma_i(M_\alpha)_\alpha&M' \leadsto M'_\alpha & O_{i,\alpha}\in \fctx & \forall \alpha,\alpha', \fctx,\tctx ||- M_\alpha == M'_{\alpha'} : \nat}{\fctx,\tctx ||- M == M' : \nat}
$$
$$
    \inference{M \leadsto M_\alpha&M' \leadsto \digamma_i (M'_\alpha)_\alpha & O_{i,\alpha}\in \fctx & \forall \alpha,\alpha', \fctx,\tctx ||- M_\alpha == M'_{\alpha'} : \nat}{\fctx,\tctx ||- M == M' : \nat}
$$
    \item For type $\bot$, we use a similar definition as above excluding the case mentioning $0$ and the case mentioning $S$ 
\end{itemize}

We can then show the usual results, all proven in $\textsc{Rocq}$ :

\begin{lemma}[reflection]
    If $\neu n$ and $\neu n'$, then $\fctx,\tctx ||- n == n' : A$.
\end{lemma}
\begin{lemma}[reification]
    If $\fctx,\tctx ||- M == M' : A$, then $M$ and $M'$ normalise.
\end{lemma}

\begin{theorem}[soundness]
    If $\fctx,\tctx |- M == M' : A$, then if $\fctx \subset \fctx'$, $\fctx',\tctx'||-\sigma == \sigma' : \Gamma$, $\fctx',\tctx' ||- M\sigma == M'\sigma' : A$
\end{theorem}
Where substitution are encoded as lists of terms and reducibility of substitution is reducubility of each of these terms.

We can then deduce that at least our theory normalises.

%\section{Meta-informations}
%
%\subsection{Time expenditure}
%I spent a lot of time tinkering with \textsc{Rocq}
%
%\subsection{Difficulties}
%
%The subject is rather vast and a bit unclear.
%
%Doing logical relations for MLTT is a large task, even before adding sheaves. My next attempt will probably start from logrel rocq insted of nothing

%\subsection{Activities}

\section{Conclusion}



\newpage

\appendix
\appendixname

\section{Dummy}

\printbibliography
\end{document}